#!/usr/bin/env bash
# 20240709_1458_est_EJR  (ericjrich.com & ejrcnc.com)
# btcV1

shopt -s dotglob

#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# F U N C T I O N S
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

mnemonic_to_pbkdf2() { python3 -c "
import sys
import hashlib

def mnemonic_to_pbkdf2(mnemonic, salt=\"mnemonic\", iterations=2048, dklen=64):
    mnemonic_bytes = mnemonic.encode(\"utf-8\")
    salt_bytes = salt.encode(\"utf-8\")

    # Derive the key using PBKDF2
    derived_key = hashlib.pbkdf2_hmac(\"sha512\", mnemonic_bytes, salt_bytes, iterations, dklen)

    return derived_key.hex()

mnemonic = sys.argv[1]
output = mnemonic_to_pbkdf2(mnemonic)
print(output)" "$1"
} #######


#---------------------------------------------------------------------------------------------------------------------------------------------------------------
pf1() { local bash2pyV1="$1"; local bash2pyV2="$2"; local Pycode_SRC=$(cat <<'PYEOF'
#!/usr/bin/env python3
import os, pyperclip, hashlib, base58, secrets, qrcode, subprocess, sys
from Cryptodome.Hash import RIPEMD160 #OldCode= from Crypto.Hash import RIPEMD160
# Secp256k1 Curve Parameters
a, b, p, n = 0, 7, 2**256 - 2**32 - 2**9 - 2**8 - 2**7 - 2**6 - 2**4 - 1, 115792089237316195423570985008687907852837564279074904382605163141518161494337
g = {'x': 55066263022277343669578718895168534326250603453777594175500187360389116729240, 'y': 32670510020758816978083085130507043184471273380659243275938904335757337482424}
#= FUNCTIONS ====================================
def modinv(a, m = p):
  a = a % m if a < 0 else a; prevy, y = 0, 1
  while a > 1:
    q = m // a; y, prevy = prevy - q * y, y; a, m = m % a, a
  return y
def double(point):
  slope = ((3 * point['x'] ** 2) * modinv((2 * point['y']))) % p; x = (slope ** 2 - (2 * point['x'])) % p; y = (slope * (point['x'] - x) - point['y']) % p
  return {'x': x, 'y': y}
def add(point1, point2):
  if point1 == point2:
    return double(point1)
  slope = ((point1['y'] - point2['y']) * modinv(point1['x'] - point2['x'])) % p; x = (slope ** 2 - point1['x'] - point2['x']) % p; y = ((slope * (point1['x'] - x)) - point1['y']) % p
  return {'x': x, 'y': y}
def multiply(k, point = g):
  current = point; binary = format(k, 'b')[1:]
  for char in binary:
    current = double(current)
    if char == '1':
      current = add(current, point)
  return current
def Prv_key_to_wif(Prv_key_hex):
  extended = "80" + Prv_key_hex + "01"; checksum = hashlib.sha256(hashlib.sha256(bytes.fromhex(extended)).digest()).digest()[:4]; extended_checksum = extended + checksum.hex(); wif = base58.b58encode(bytes.fromhex(extended_checksum)).decode()
  return wif
def hash160(data):
  binary = bytes.fromhex(data); sha256 = hashlib.sha256(binary).digest(); ripemd160 = RIPEMD160.new(); ripemd160.update(sha256); hash160_bytes = ripemd160.digest(); hash160_hex = hash160_bytes.hex()
  return hash160_hex
#= User Choice (1=User Input Key / 2=Gen. Key) ==
choice = sys.argv[1]
if choice == '1':
  PvKHex = sys.argv[2]
  #PvKHex = input()
  if len(PvKHex) != 64:
    print("Invalid Prv key length."); exit()
elif choice == '2':
  prvkeybytes = secrets.token_bytes(32); PvKHex = prvkeybytes.hex()
else:
  print("Invalid choice."); exit()
#= PrvKey to bytes ==========================
prvkeybytes = bytes.fromhex(PvKHex)
#= PrvKey To PubKey ======================
prvkeyint = int.from_bytes(prvkeybytes, byteorder="big"); point = multiply(prvkeyint)
#= Pubic(x,y) to hex ============================
x = format(point['x'], '064x'); y = format(point['y'], '064x')
#= Compressed Pub key ========================
prefix = '02' if point['y'] % 2 == 0 else '03'; PbKHex = prefix + x
#= Hash160 of the Pub key ====================
PbKh160 = hash160(PbKHex); versioned_hash = '00' + PbKh160; checksum = hashlib.sha256(hashlib.sha256(bytes.fromhex(versioned_hash)).digest()).digest()[:4]; final_Addrs = versioned_hash + checksum.hex(); PbAddr = base58.b58encode(bytes.fromhex(final_Addrs)).decode()
#= Prv Key to WIF ===========================
wif = Prv_key_to_wif(PvKHex)
#= VARS =========================================
print(f"{PvKHex}|{wif}|{PbKHex}|{PbKh160}|{PbAddr}", flush=True)
PYEOF
)
local pycode_OUT=$(python3 -c "$Pycode_SRC" "$bash2pyV1" "$bash2pyV2")
IFS='|' read -r PvKHex wif PbKHex PbKh160 PbAddr <<< "$pycode_OUT"
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
ToLogs() { local Tl1="$PvKHex"; local PhLN; PbAddrUrl="https://mempool.space/address/$PbAddr"
touch "$PhFN"; > "$PhFN"; touch "$PhF"; > "$PhF"
local Tl2=$(hex2bin $Tl1); local Tl3=$(Sha256bits $Tl2 | awk '{print $1}' | cut -c1-2); local Tl4=$(hex2bin $Tl3); local Tl5=$Tl2$Tl4
local TlData=("Private Key: $PvKHex" "WIF(p2pkh): $wif" "Public Key: $PbKHex" "Public Key Hash160: $PbKh160" "Address: $PbAddr" "URL: $PbAddrUrl")
for (( i=0; i<${#Tl5}; i+=11 )); do Tl6=${Tl5:$i:11}; echo $((2#${Tl6})); done > "$PhFN"
while read PhLN; do PhLN=$((PhLN + 1)); sed -n "${PhLN}p" "$bitwords"; done < "$PhFN" > "$PhF"
local PhStr=$(cat "$PhF" | tr '\n' ' ' | sed 's/ *$//')
clear; echo; echo 'saving.......'; touch $logF $logF1
for i in "${TlData[@]}"; do value="${i#*: }"; TxtToQr "$value" >>$logF; echo -e "\n⬆️ ${i%%:*}⬆️\n" >>$logF; done
echo -e "**********$(date -u '+%Y-%m-%d %H:%M:%S') UTC **************** $(date '+%Y-%m-%d %H:%M:%S') LocalTime ************
*UserOGin*        $userOGin
*UserOGout*       $userOGout
*UserOGout1*      $userOGout1
*Prv Key*         $PvKHex
*WIF(p2pkh)*      $wif
*PDKDF2 SEED*     $(mnemonic_to_pbkdf2 "$PhStr")
*TESTING.PHRASE*  $PhStr
*Entropy (bin)*   $Tl2
*Checksum*        hex=$Tl3   bin= $Tl4
*Entropy & Chksm* $Tl5
*Pub Key*         $PbKHex
*Pub Key Hash160* $PbKh160
*Pub Addrs*       $PbAddr
*URL*             $PbAddrUrl
*Balance*         $balnow\tBTC
*Volume*          $balvol\tBTC
*************************************************************************************************************************************************************************
" | tee -a "$logF" "$logF1"; echo "**** Saved In File: $logF & "$logF1" ****"; }
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
ToTerm() { PbAddrUrl=''; local Tt1="$PvKHex"; local PhLN; PbAddrUrl="https://mempool.space/address/$PbAddr"; toclip "$PbAddrUrl"
touch "$PhFN"; > "$PhFN"; touch "$PhF"; > "$PhF"
local Tt2=$(hex2bin $Tt1); local Tt3=$(Sha256bits $Tt2 | awk '{print $1}' | cut -c1-2); local Tt4=$(hex2bin $Tt3); local Tt5=$Tt2$Tt4
local TtData=("Private Key: $PvKHex" "WIF(p2pkh): $wif" "Public Key: $PbKHex" "Public Key Hash160: $PbKh160" "Address: $PbAddr" "URL: $PbAddrUrl")
for (( i=0; i<${#Tt5}; i+=11 )); do Tt6=${Tt5:$i:11}; echo $((2#${Tt6})); done > "$PhFN"
while read PhLN; do PhLN=$((PhLN + 1)); sed -n "${PhLN}p" "$bitwords"; done < "$PhFN" > "$PhF"
local PhStr=$(cat "$PhF" | tr '\n' ' ' | sed 's/ *$//')
clear; echo; echo '=============== QR CODES =================='
for i in "${TtData[@]}"; do value="${i#*: }"; TxtToQr "$value"; echo -e "\n⬆️ ${i%%:*}⬆️\n"; done
echo -e "*************************************************************************************************************************************************************************
*UserOGin*        $userOGin
*UserOGout*       $userOGout
*UserOGout1*      $userOGout1
${TInvert}${TBold}${TFYel}*Prv Key*         ${TFBlu}$PvKHex${TOff}
${TInvert}${TBold}${TFYel}*WIF(p2pkh)*      ${TFBlu}$wif${TOff}
${TInvert}${TBold}${TFYel}*PDKDF2 SEED*     ${TFBlu}$(mnemonic_to_pbkdf2 "$PhStr")${TOff}
${TDim}*TESTING.PHRASE*  $PhStr${TOff}
*Entropy (bin)*   $Tt2
*Checksum*        hex= $Tt3    bin=$Tt4
*Entropy & Chksm* $Tt5
*Pub Key*         $PbKHex
*Pub Key Hash160* $PbKh160
${TInvert}${TBold}${TFYel}*Pub Addrs*       ${TFBlu}$PbAddr${TOff}
*URL [Copied]*    $PbAddrUrl
${TInvert}${TBold}${TFYel}*Balance*         ${TFBlu}$balnow\tBTC${TOff}
${TInvert}${TBold}${TFYel}*Volume*          ${TFBlu}$balvol\tBTC${TOff}
*************************************************************************************************************************************************************************
"; }
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
genbinlen() {
    local length="$1"
    local binary=""
    for i in $(seq 1 "$length"); do
        binary+=$((RANDOM % 2))
    done
    echo "$binary"
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
randtest() {
    local r='101'
    local r="$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001$(genbinlen 6)1010001001"
    echo "$r"
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
prv2wif() {
  local private_key=$1             # Capture Input "The 64 char. hex. prv. key"
  local version="80"               # Mainnet version prefix
  local compression="01"           # Compression extension
  local extended_key="${version}${private_key}${compression}"   # Add version prefix & the compression extension to the private key
  local sha256_1=$(echo -n "${extended_key}" | xxd -r -p | sha256sum -b | awk '{print $1}')   # Perform SHA-256 hash of the extended key
  local sha256_2=$(echo -n "${sha256_1}" | xxd -r -p | sha256sum -b | awk '{print $1}')       # Perform SHA-256 hash of the previous hash
  local checksum=${sha256_2:0:8}   # Get the first 4 bytes of the second hash (checksum)
  local extended_key_checksum="${extended_key}${checksum}"      # Concatenate the extended key and the checksum
  local base58_result=$(echo -n "${extended_key_checksum}" | xxd -r -p | base58)    # Convert the result to base58
  echo -n "${base58_result}"       # Output the WIF
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
hex2nato() { local hex=$1; local result=""; local char; for ((i = 0; i < ${#hex}; i++)); do
	char="${hex:i:1}"
	case "$char" in
		0) result+="zero";; 1) result+="one";; 2) result+="two";; 3) result+="three";; 4) result+="four";; 5) result+="five";; 6) result+="six";; 7) result+="seven";; 8) result+="eight";;
		9) result+="nine";; [aA]) result+="alpha";; [bB]) result+="bravo";; [cC]) result+="charlie";; [dD]) result+="delta";; [eE]) result+="echo";; [fF]) result+="foxtrot";; *) result+="$char";;
	esac
	if ((i < ${#hex} - 1)); then result+=", "; fi
done
echo "$result"; }
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
function txt2t9 {
    local input="${1,,}"
    local output=""
    declare -A mapping=(
        [ ]=0
        [a]=1 [b]=1 [c]=1
        [d]=2 [e]=2 [f]=2
        [g]=3 [h]=3 [i]=3
        [j]=4 [k]=4 [l]=4
        [m]=5 [n]=5 [o]=5
        [p]=6 [q]=6 [r]=6
        [s]=7 [t]=7 [u]=7
        [v]=8 [w]=8 [x]=8
        [y]=9 [z]=9

    )
#og T9
#        [ ]=1 [a]=2 [b]=2 [c]=2
#        [d]=3 [e]=3 [f]=3
#        [g]=4 [h]=4 [i]=4
#        [j]=5 [k]=5 [l]=5
#        [m]=6 [n]=6 [o]=6
#        [p]=7 [q]=7 [r]=7 [s]=7
#        [t]=8 [u]=8 [v]=8
#        [w]=9 [x]=9 [y]=9 [z]=9

    for (( i=0; i<${#input}; i++ )); do
        char="${input:$i:1}"
        if [[ "${mapping[$char]}" ]]; then
            output+="${mapping[$char]}"
        else
            output+="$char"
        fi
    done

    echo "$output"
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
dec2b62() { local decimal="$1"; local base62_representation; base62_representation=$(python3 - <<END
def decimal_to_base62(decimal):
    base62_chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    base62_string = []

    while decimal > 0:
        remainder = decimal % 62
        base62_string.append(base62_chars[remainder])
        decimal //= 62

    if not base62_string:
        base62_string.append('0')

    return ''.join(reversed(base62_string))

decimal_number = $decimal
base62_to_print = decimal_to_base62(decimal_number)
print(base62_to_print)
END
)
echo "$base62_representation"; }
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
b622dec() { local base62_string="$1"; local decimal_result; decimal_result=$(python3 - <<END
def base62_to_decimal(base62_string):
    base62_chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    decimal_number = 0
    base = 62

    for char in base62_string:
        decimal_number = decimal_number * base + base62_chars.index(char)

    return decimal_number

base62_input = "$base62_string"
decimal_output = base62_to_decimal(base62_input)
print(decimal_output)
END
)
echo "$decimal_result"; }
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
balnvol() {
# Replace this with your actual wallet address
local ADDRESS="$1"
local RESPONSE=$(curl -sSL "https://mempool.space/api/address/$ADDRESS")

# Extract balance and total received from JSON response using jq
local TOTAL_RECEIVED=$(echo "$RESPONSE" | jq -r '.chain_stats.funded_txo_sum')
local SPENT=$(echo "$RESPONSE" | jq -r '.chain_stats.spent_txo_sum')
local BALANCE=$((TOTAL_RECEIVED - SPENT))

TOTAL_RECEIVED_BTC=$(echo "scale=8; $TOTAL_RECEIVED / 100000000" | bc)
BALANCE_BTC=$(echo "scale=8; $BALANCE / 100000000" | bc)

balnow="$BALANCE_BTC"
balvol="$TOTAL_RECEIVED_BTC"
}
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
jumpto() { local LV1=$1; local LV2=$(sed -n "/$LV1:/{:a;n;p;ba};" $0 | grep -v ':$'); sleep .1; eval "$LV2"; exit; }
crap() { sleep .2; read -n 1 -p '*ANY-KEY*'; echo; }
GetDeps() { clear; echo 'Ctrl-C now if you dont want to install Dependencies'; crap; for i in "${Dep_Apt[@]}"; do if ! dpkg -l | grep -q "^ii  $i "; then echo "Installing $i..."; sudo apt install -y "$i"; else echo "You Have $i"; fi; done; for i in "${Dep_Pip3[@]}"; do if ! pip3 show "$i" &> /dev/null; then echo "Installing $i..."; pip3 install "$i"; else echo "$i is already installed."; fi; done; }
toclip() { echo -n "$1" | xclip -selection clipboard; }
TxtToQr() { local In1="$1"; local Out=$(qrencode -m 2 -t utf8 <<< "$In1"); echo "$Out"; }
ClipTxtToQr() { local In1=$(xclip -o -selection clipboard); if [ -z "$In1" ]; then echo "Clipboard is empty."; return 1; fi; local Out=$(qrencode -m 2 -t utf8 <<< "$In1"); echo "$Out"; }
readclipQR() { xclip -selection clipboard -t image/png -o > /tmp/clipboard.png; local Out=$(zbarimg --quiet --raw /tmp/clipboard.png); echo "Decoded text from QR code:"; echo "$Out"; rm /tmp/clipboard.png; }
stock_calc() { local purchase_price; local total_investment; local current_price; local quantity; local current_value; local profit_or_loss; validate_input() { while true; do read -p "$1" input; if [[ $input =~ ^[0-9]*(\.[0-9]*)?$ ]]; then break; else echo "Invalid input. Please enter a valid numeric value."; fi; done; }; clear; validate_input "Enter bitcoin start-price (per coin): "; purchase_price=$input; validate_input "Enter what we bought (in dollars): "; total_investment=$input; validate_input "Enter bitcoin end-price (per coin): "; current_price=$input; quantity=$(bc <<< "scale=8; $total_investment / $purchase_price"); current_value=$(bc <<< "scale=2; $current_price * $quantity"); profit_or_loss=$(bc <<< "scale=2; ($current_price * $quantity) - $total_investment"); clear; printf "Original Unit Value:\n \$%.2f\n" "$purchase_price"; printf "Original Investment Value:\n \$%.2f\n" "$total_investment"; printf "Current Unit Value:\n \$%.2f\n" "$current_price"; printf "Current Investment Value:\n \$%.2f\n" "$current_value"; printf "Profit OR Loss:\n \$%.2f\n" "$profit_or_loss"; echo; }
txt2ssl() { local In="$1"; local Out=$(echo -n "$In" | openssl aes-256-cbc -a -salt -pass pass:"$EncMsgPass" -pbkdf2); echo -n "$Out"; }
ssl2txt() { local In="$1"; local Out=$(echo -n "$In" | openssl aes-256-cbc -d -a -pass pass:"$EncMsgPass" -pbkdf2); echo -n "$Out"; }
txt2b64() { local In="$1"; local Out=$(echo -n "$In" | base64); echo -n "$Out"; }
b642txt() { local In="$1"; local Out=$(echo -n "$In" | base64 -d); echo -n "$Out"; }
txt2b58() { local In="$1"; local Out=$(echo -n "$In" | base58); echo -n "$Out"; }
b582txt() { local In="$1"; local Out=$(echo -n "$In" | base58 -d); echo -n "$Out"; }
qrclip2txt()  { xclip -selection clipboard -t image/png -o > /tmp/qr.png; local qr_result=$(zbarimg -q --raw /tmp/qr.png); if [ -n "$qr_result" ]; then echo -n "$qr_result" | xclip -selection clipboard; echo "QR code result copied to clipboard: $qr_result"; else echo "Failed to decode QR code."; fi; rm -f /tmp/qr.png; }
ocrclip2txt() { xclip -selection clipboard -t image/png -o > /tmp/ocr.png; local ocr_result=$(tesseract /tmp/ocr.png - 2>/dev/null); if [ -n "$ocr_result" ]; then echo -n "$ocr_result" | xclip -selection clipboard; echo "ocr result copied to clipboard: $ocr_result"; else echo "Failed to decode ocr."; fi; rm -f /tmp/ocr.png; }
hex2b62() { local In="$1"; local in2dec=$(hex2dec "$In"); local out=$(dec2b62 "$in2dec"); echo "$out"; }
b622hex() { local In="$1"; local in2dec=$(b622dec "$In"); local out=$(dec2hex "$in2dec"); echo "$out"; }
hex2txt() { local In="$1"; In=${In,,}; In=$(echo -n $In | sed 's/ //g'); local Out=$(echo -n "$In" | xxd -r -p); echo -n "$Out"; }
txt2hex() { local In="$1"; local Out=$(echo -n "$In" | xxd -p | tr -d '\n'); echo -n "$Out"; }
dice() { local result=""; local roll=""; for ((i = 1; i <= 99; i++)); do clear; echo -e "Roll #$i (Last Roll Was=$roll)\nCurrent Results=$result\nRoll The Dice and Enter The Value\n[1-5 are normal 6=0]"; read -rsn1 roll; result="${result}${roll}"; done; echo -n "$result"; dice_OUT="$result"; }
hex2b6() { local IN=$(echo "$1" | rev); local dec=$(hex2dec "$IN"); local base6_number=$(echo "obase=6; $dec" | bc | tr -d '\n\\'); echo -n "$base6_number"; }
b62hex() { local base6="$1"; local result=$(echo "obase=16; ibase=6; $base6" | bc | tr -d '\n\\'); result=${result,,}; echo -n "$result"; }
bin2dec() { local bin="$1"; local dec=""; dec=$(echo "ibase=2; $bin" | bc | tr -d '\n\\'); echo -n "$dec"; }
dec2bin() { local dec="$1"; local hex=$(dec2hex "$dec"); local bin=$(hex2bin "$hex"); echo -n "$bin"; }
bin2hex() { local bin="$1"; local hex=""; while (( (i + ${#bin}) % 4 != 0 )); do bin="0$bin"; done; for ((i = 0; i < ${#bin}; i += 4)); do chunk="${bin:i:4}"; case "$chunk" in 0000) hex+="0" ;; 0001) hex+="1" ;; 0010) hex+="2" ;; 0011) hex+="3" ;; 0100) hex+="4" ;; 0101) hex+="5" ;; 0110) hex+="6" ;; 0111) hex+="7" ;; 1000) hex+="8" ;; 1001) hex+="9" ;; 1010) hex+="a" ;; 1011) hex+="b" ;; 1100) hex+="c" ;; 1101) hex+="d" ;; 1110) hex+="e" ;; 1111) hex+="f" ;; *) echo "Invalid binary input: $chunk"; return 1 ;; esac; done; echo -n "$hex"; }
hex2bin() { local hex=$1; for ((i=0; i<${#hex}; i++)); do case ${hex:$i:1} in 0) echo -n "0000" ;; 1) echo -n "0001" ;; 2) echo -n "0010" ;; 3) echo -n "0011" ;; 4) echo -n "0100" ;; 5) echo -n "0101" ;; 6) echo -n "0110" ;; 7) echo -n "0111" ;; 8) echo -n "1000" ;; 9) echo -n "1001" ;; [Aa]) echo -n "1010" ;; [Bb]) echo -n "1011" ;; [Cc]) echo -n "1100" ;; [Dd]) echo -n "1101" ;; [Ee]) echo -n "1110" ;; [Ff]) echo -n "1111" ;; esac; done; }
dec2hex() { local dec="$1"; local hex=""; hex=$(echo "ibase=10; obase=16; $dec" | bc); echo -n "${hex,,}"; }
hex2dec() { local hex="$1"; local bin=$(hex2bin "$hex"); local dec=$(bin2dec "$bin"); echo -n "$dec"; }
Sha256bits() { echo -n $1 | shasum -a 256 -0 | tr -d '\n\\'; } #ALSO WORKS: Sha256bits() { echo -n $1 | shasum -a 256 -0 | awk '{print $1}'; }
txt2sha256sum() { echo -n "$1" | sha256sum | awk '{print $1}'; } # same= { echo -n "$1" | shasum -a 256 | awk '{print $1}'; }
txt2sha512sum() { echo -n "$1" | sha512sum | awk '{print $1}'; }
wif2prv() { local IN="$1"; local OUT; OUT=$(echo -n "$IN" | base58 -d | xxd -p | tr -d '\n\\'); OUT=${OUT,,}; OUT=${OUT:2}; OUT=${OUT:0:64}; echo -n "$OUT"; }
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
wipevars() { for i in "${vars2wipe[@]}"; do eval $i=""; done; }
#---------------------------------------------------------------------------------------------------------------------------------------------------------------


#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# V A R I A B L E S
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

#misc
Dep_Pip3=(mnemonic ecdsa pycryptodome pyperclip qrcode base58)
Dep_Apt=(); Dep_Apt+=(base58 basez dc espeak feh festival figlet flite gifsicle gnupg hashalot imagemagick img2pdf jp2a jpegoptim jq minimodem oathtool openssl pandoc pngcrush python3 python3-pip qrencode ruby-ascii85 sox speech-dispatcher tesseract-ocr webcamoid webp whiptail wkhtmltopdf xautomation xbindkeys xclip xdotool yad zbar-tools zenity zint-qt); Dep_Apt+=(python3-base58 python3-ecdsa python3-mnemonic python3-pycryptodome python3-pyperclip python3-qrcode)
PhFN="/tmp/numbers.txt"; PhF="/tmp/seed_phrase.txt"
logF="$HOME/Desktop/basexQR.txt"
logF1="$HOME/Desktop/basexTXT.txt"
bitwords="$HOME/a-me/z-share/code/bitwords.txt"

#text effects
TOff='\e[0m'; TFBlk='\e[30m'; TFRed='\e[31m'; TFGre='\e[32m'; TFYel='\e[33m'; TFBlu='\e[34m'; TFMag='\e[35m'; TFCya='\e[36m'; TFWhi='\e[37m'; TBBlk='\e[40m'; TBRed='\e[41m'; TBGre='\e[42m'; TBYel='\e[43m'; TBBlu='\e[44m'; TBMag='\e[45m'; TBCya='\e[46m'; TBWhi='\e[47m'; TBold='\e[1m'; TDim='\e[2m'; TItalic='\e[3m'; TUnderline='\e[4m'; TBlink='\e[5m'; TInvert='\e[7m'; TConceal='\e[8m'
TPipe="${TBCya}|${TOff}"; TFavs="${TFYel}${TBold}"
#vars to wipe
vars2wipe=(b582txt_IN b582txt_OUT b622dec_IN b622dec_OUT b622hex_IN b622hex_OUT b62hex_IN b62hex_OUT b642txt_IN b642txt_OUT balnow balvol bash2pyV1 bash2pyV2 bin2dec_IN bin2dec_OUT bin2hex_IN bin2hex_OUT bin2sha256_IN bin2sha256_OUT chunk current_price current_value dec2b62_IN dec2b62_OUT dec2bin_IN dec2bin_OUT dec2hex_IN dec2hex_OUT dice_IN dice_OUT EncMsgClip EncMsgPass FileToStoreNumbers FileToStoreSeedPhrase hex2b62_IN hex2b62_OUT hex2b6_IN hex2b6_OUT hex2bin_IN hex2bin_OUT hex2dec_IN hex2dec_OUT hex2nato_IN hex2nato_OUT hex2txt_IN hex2txt_OUT InKey input junk line output PbAddr PbAddrUrl PbKh160 PbKHex PhraseBinaryString PhraseBinaryStringAsRowOf11Chars PhraseBinaryStringNoChecksum PhraseBinaryStringSpacedEvery11Chars PhraseBinaryStringSpacedEvery11CharsInRows PhraseWordStringSpaced profit_or_loss prv2wif_IN prv2wif_OUT prvkeyin prvkeyinlength prvkeyinpadding prvkeyinzeros purchase_price PvKHex pycode_OUT Pycode_SRC quantity SayClip ssl2txt_IN ssl2txt_OUT substring ThisLineDecCalc ThisLineDecCalcToBin ThisLineDecRaw ThisWord total_investment tv tv1 tv2 tvi tvo txt2b58_IN txt2b58_OUT txt2b64_IN txt2b64_OUT txt2hex_IN txt2hex_OUT txt2ssl_IN txt2ssl_OUT txt2t9_IN txt2t9_OUT userOGin userOGout userOGout1 value wif wif2prv_IN wif2prv_OUT WordListFile)

#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# B O D Y
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma:
wipevars
clear
echo -e "\t${TInvert}   *** EJRCNC CRYTO/BTC TOOLS (20240708_1325_est_EJR) ***${TOff}
${TOff}
${TBCya}================  M a i n  M e n u  ==========================================${TOff}
 1 ${TPipe}${TFavs} Make BTC Wallet    ( Generated: Random Entropy      ) ${TItalic}[Prompt & SubMenu]${TOff}
 2 ${TPipe}${TFavs} Make BTC Wallet    ( Enter Prv Key: Hex    L= 64    ) ${TItalic}[Prompt & SubMenu]${TOff}
 3 ${TPipe}${TFavs} Make BTC Wallet    ( Enter Prv Key: Bin    L= 256   ) ${TItalic}[Prompt & SubMenu]${TOff}
 4 ${TPipe}${TFavs} Make BTC Wallet    ( Enter Prv Key: Dec    L= Any   ) ${TItalic}[Prompt & SubMenu]${TOff}
 5 ${TPipe}${TFavs} Make BTC Wallet    ( Enter Prv Key: WIF    L= 51-52 ) ${TItalic}[Prompt & SubMenu]${TOff}
 6 ${TPipe}${TFavs} Make BTC Wallet    ( Enter Prv Key: String L= Any   ) ${TItalic}[Prompt & SubMenu]${TOff}
 7 ${TPipe} Experiments TMP${TOff}
 8 ${TPipe}${TDim} TESTING: BtcWallet ( Enter Mnemonic: 24 word        ) [Prompt & SubMenu]${TOff}
 9 ${TPipe}${TDim} TESTING: Mnemonic --> Binary Rows${TOff}
 0 ${TPipe}${TFavs} Base Converter Calculators ${TItalic}[SubMenu]${TOff}
 - ${TPipe}${TFavs} En/Decrypt Messages        ${TItalic}[SubMenu]${TOff}
 q ${TPipe} Speak Clipboard${TOff}
 w ${TPipe} Hex 2 Nato${TOff}
 e ${TPipe} Stock Calc${TOff}
 r ${TPipe} CLipboard:  QR To Text  ** have image on clipboard already **${TOff}
 t ${TPipe} Clipboard: OCR To Text  ** have image on clipboard already **${TOff}
 y ${TPipe}${TFavs} CHECK BAL OF ADDRESS IN: BASH${TOff}
 u ${TPipe}${TFavs} CHECK BAL OF ADDRESS IN: BROWSER${TOff}
 p ${TPipe} Dependency Installer${TOff}
 m ${TPipe} Readme${TOff}
 \ ${TPipe} EXIT${TOff}"
read -rsn1 InKey; echo; InKey=${InKey,,}; clear; case "$InKey" in
'1')  pf1 '2'; jumpto mmb;;
'2')  echo -e "*Largest (HEX)* (64 chars)= fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140\n\nEnter Prv Key (hex):"; read prvkeyin; userOGin="$prvkeyin"; prvkeyin=${prvkeyin,,}; prvkeyinlength=${#prvkeyin}; if [ $prvkeyinlength -lt 64 ]; then prvkeyinpadding=$((64 - prvkeyinlength)); prvkeyinzeros=$(printf '0%.0s' $(seq 1 $prvkeyinpadding)); prvkeyin="${prvkeyinzeros}${prvkeyin}"; fi; pf1 '1' "$prvkeyin"; jumpto mmb;;
'3')  echo -e "*Largest (BIN)* (256 chars)= 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111010111010101011101101110011100110101011110100100010100000001110111011111111010010010111101000110011010000001101100100000101000000\n\nEnter Prv Key (bin):"; read prvkeyin; userOGin="$prvkeyin"; prvkeyinlength=${#prvkeyin}; if [ $prvkeyinlength -lt 256 ]; then prvkeyinpadding=$((256 - prvkeyinlength)); prvkeyinzeros=$(printf '0%.0s' $(seq 1 $prvkeyinpadding)); prvkeyin="${prvkeyinzeros}${prvkeyin}"; fi; prvkeyin=$(echo -n "$prvkeyin"); prvkeyin=$(bin2hex "$prvkeyin"); userOGout="$prvkeyin"; pf1 '1' "$prvkeyin"; jumpto mmb;;
'4')  echo -e "*Largest (DEC)* (78 chars)= 115792089237316195423570985008687907852837564279074904382605163141518161494336\n\nEnter Prv Key (dec):"; read prvkeyin; userOGin="$prvkeyin"; prvkeyin=$(echo -n "$prvkeyin"); prvkeyin=$(dec2hex "$prvkeyin"); prvkeyin=$(printf "%064s" "$prvkeyin" | tr ' ' 'f'); userOGout="$prvkeyin"; pf1 '1' "$prvkeyin"; jumpto mmb;;
'5')  echo -e "\n\nEnter WIF (b58 51-52 chars):"; read prvkeyin; userOGin="$prvkeyin"; prvkeyin=$(wif2prv "$prvkeyin"); userOGout="$prvkeyin"; prvkeyin=${prvkeyin,,}; prvkeyinlength=${#prvkeyin}; if [ $prvkeyinlength -lt 64 ]; then prvkeyinpadding=$((64 - prvkeyinlength)); prvkeyinzeros=$(printf '0%.0s' $(seq 1 $prvkeyinpadding)); prvkeyin="${prvkeyinzeros}${prvkeyin}"; fi; pf1 '1' "$prvkeyin"; jumpto mmb;;
'6')  echo -e "\n\nEnter String For Conversion (sha256sum):"; read prvkeyin; userOGin="$prvkeyin"; prvkeyin=$(txt2sha256sum "$prvkeyin"); userOGout="$prvkeyin"; prvkeyin=${prvkeyin,,}; prvkeyinlength=${#prvkeyin}; if [ $prvkeyinlength -lt 64 ]; then prvkeyinpadding=$((64 - prvkeyinlength)); prvkeyinzeros=$(printf '0%.0s' $(seq 1 $prvkeyinpadding)); prvkeyin="${prvkeyinzeros}${prvkeyin}"; fi; pf1 '1' "$prvkeyin"; jumpto mmb;;
'7')  jumpto mma7;;
'8')  jumpto mma8;;
'9')  jumpto mma9;;
'0')  jumpto mma0;;
'-')  jumpto mmam;;
'q')  SayClip=$(xclip -o -selection clipboard); echo -e "==== Reading The Clipboard ====\n$SayClip"; echo "$SayClip" | festival --tts; crap;;
'w')  echo 'enter Hex (for nato)'; read hex2nato_IN; hex2nato_IN=${hex2nato_IN,,}; hex2nato_OUT=$(hex2nato "$hex2nato_IN"); toclip "$hex2nato_OUT"; clear; echo "$hex2nato_OUT"; crap;;
'e')  stock_calc; crap;;
'r')  qrclip2txt; crap;;
't')  ocrclip2txt; crap;;
'y') clear; echo 'Enter Address (to check bal in bash)   '; read PbAddr; echo '--------------------'; balnvol "$PbAddr"; echo -e "Bal:\t$balnow\nVol:\t$balvol"; crap;;
'u') clear; echo 'Enter Address (to check bal in browser)'; read PbAddr; echo '--------------------'; xdg-open "https://mempool.space/address/$PbAddr" >>/dev/null 2>&1 & disown;;
'p')  GetDeps; crap;;
'm')  jumpto readme;;
'\')  rm "$PhFN"; rm "$PhF"; exit 0;;
  *)  jumpto mma;;
esac
jumpto mma
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma7:
  clear
  echo -e "==== Mnemonic 2 pbkdf2 seed ====\n"; read prvkeyin; userOGin="$prvkeyin"
  tmp=$(mnemonic_to_pbkdf2 "$prvkeyin")
  echo "$tmp"; crap
jumpto mma
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma8:
  # Get Phrase From User
    clear; echo -e "==== Mnemonic 2 PrvKey ===="; read PhraseWordStringSpaced; userOGin="$PhraseWordStringSpaced"
  # Loop Through Each Word
    for ThisWord in $PhraseWordStringSpaced; do
      ThisLineDecRaw=$(grep -n -w "$ThisWord" "$bitwords" | cut -d: -f1) # Raw LineNum Per Word
      ThisLineDecCalc=$((ThisLineDecRaw - 1)) # ( LineNums - 1 )
      ThisLineDecCalcToBin=$(printf "%011d" $(echo "obase=2;$ThisLineDecCalc" | bc)) # LineNums To Bin
      PhraseBinaryString+="$ThisLineDecCalcToBin" #add number as bin to the chain
    done
  # Remove Checksum Bytes From the end of the chain
    if [ ${#PhraseBinaryString} -eq 264 ]; then PhraseBinaryStringNoChecksum="${PhraseBinaryString:0:-8}"
      elif [ ${#PhraseBinaryString} -eq 132 ]; then PhraseBinaryStringNoChecksum="${PhraseBinaryString:0:-4}"
      else clear; echo 'Length issue with words'; sleep 2; jumpto mma
    fi
  # Prep For MMB
prvkeyin="$PhraseBinaryStringNoChecksum"
prvkeyinlength=${#prvkeyin}
prvkeyin=$(echo -n "$prvkeyin")
prvkeyin=$(bin2hex "$prvkeyin")
userOGout="$prvkeyin"
pf1 '1' "$prvkeyin"
jumpto mmb
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma9:
#===testing====
  # Display A Prompt To Get The Words From The User Seperated By Spaces In A String
  clear; echo -e "==== Mnemonic 2 binaries ====\n  FYI: (Requires File @ bitwords.txt\nEnter Phrase:"; read PhraseWordStringSpaced
  # Loop Through Each Word
  for ThisWord in $PhraseWordStringSpaced; do
    # Get The Raw numberic value for the line number of the word
    ThisLineDecRaw=$(grep -n -w "$ThisWord" "$bitwords" | cut -d: -f1)
    # Subtract 1 from the raw number to get a usable number (this is because we start with line 1 and zero is a possibility so we subtract 1) [could probably be explained better]
    ThisLineDecCalc=$((ThisLineDecRaw - 1))
    # convert last number to binary
    ThisLineDecCalcToBin=$(printf "%011d" $(echo "obase=2;$ThisLineDecCalc" | bc))
    # add last binary to a string
    PhraseBinaryString+="$ThisLineDecCalcToBin"
  done
  # Initialize variable to store formatted string
  PhraseBinaryStringAsRowOf11Chars=""

  # Loop through the binary string, adding a space after every 11 characters
  for ((i = 0; i < ${#PhraseBinaryString}; i += 11)); do
    # Extract a substring of 11 characters starting from index i
    substring="${PhraseBinaryString:i:11}"
    # add substing with a space to new string
    PhraseBinaryStringSpacedEvery11Chars+="$substring "
  done
  # create rows
  PhraseBinaryStringSpacedEvery11CharsInRows=$(for i in $PhraseBinaryStringSpacedEvery11Chars; do echo $i; done)
  # send list to clipboard
  toclip "$PhraseBinaryStringSpacedEvery11CharsInRows"
  # show list to user
  echo "$PhraseBinaryStringSpacedEvery11CharsInRows"

read -p 'Hit Enter' junk
jumpto mma

#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mmb:
sleep 1
balnvol "$PbAddr"
mmbalt:
clear
ToTerm
echo -e "
======= Crypto After Gen. Menu ====================================================================================
 1 | Just Save To $logF & $logF1
 2 | Delete $logF & $logF1
 3 | Open URL
 \ | Back To Main Menu   ${TBlink}❓️❓️❓️❓️❓️❓️${TOff}"
read -rsn1 InKey; echo; InKey=${InKey,,}; clear; case "$InKey" in
'1') ToLogs;;
'2') rm "$logF" "$logF1";;
'3') xdg-open "$PbAddrUrl" >>/dev/null 2>&1 & disown;;
'\') jumpto mma;;
  *) jumpto mmbalt;;
esac
jumpto mmbalt
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0:
clear
echo -e "== BASE Converter ===
 1 | HEX 2 BIN
 2 | HEX 2 DEC
 3 | BIN 2 HEX
 4 | BIN 2 DEC
 5 | DEC 2 HEX
 6 | DEC 2 BIN
 7 | TXT 2 B64
 8 | B64 2 TXT
 9 | TXT 2 HEX
 0 | HEX 2 TXT
 q | TXT 2 B58
 w | B58 2 TXT
 e | DEC 2 B62
 r | B62 2 DEC
 t | HEX 2 B62
 y | B62 2 HEX
 a | WIF 2 PRV (BASE58 WIF TO HEX Prv KEY)
 s | PRV 2 WIF (HEX Prv KEY TO BASE58 WIF)
 d | hex 2 b6 (hex TO base6)
 f | b6 2 hex (base6 to base16) [good for dice]
 g | roll dice as base6
 h | TXT 2 SHA256SUM
 j | TXT 2 T9
 \ | EXIT"
read -rsn1 InKey; echo; InKey=${InKey,,}; clear; case "$InKey" in
'1') jumpto mma01 ;;
'2') jumpto mma02 ;;
'3') jumpto mma03 ;;
'4') jumpto mma04 ;;
'5') jumpto mma05 ;;
'6') jumpto mma06 ;;
'7') jumpto mma07 ;;
'8') jumpto mma08 ;;
'9') jumpto mma09 ;;
'0') jumpto mma00 ;;

'q') jumpto mma0q ;;
'w') jumpto mma0w ;;
'e') jumpto mma0e ;;
'r') jumpto mma0r ;;
't') jumpto mma0t ;;
'y') jumpto mma0y ;;

'a') jumpto mma0a ;;
's') jumpto mma0s ;;
'd') jumpto mma0d ;;
'f') jumpto mma0f ;;
'g') jumpto mma0g ;;
'h') jumpto mma0h ;;
'j') jumpto mma0j ;;

'\') jumpto mma ;;
  *) jumpto mma0 ;;
esac
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma01:
tv='hex2bin'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma02:
tv='hex2dec'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma03:
tv='bin2hex'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma04:
tv='bin2dec'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma05:
tv='dec2hex'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma06:
tv='dec2bin'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma07:
tv='txt2b64'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma08:
tv='b642txt'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma09:
tv='txt2hex'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma00:
tv='hex2txt'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0q:
tv='txt2b58'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0w:
tv='b582txt'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0e:
tv='dec2b62'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0r:
tv='b622dec'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0t:
tv='hex2b62'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0y:
tv='b622hex'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0a:
tv='wif2prv'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0s:
tv='prv2wif'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0d:
tv='hex2b6'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0f:
tv='b62hex'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0g:
dice_IN=""; dice_OUT=""; clear; dice; toclip "$dice_OUT"
echo -e "\n----------------------------------------\nDice As Base 6 (Length= ${#dice_OUT})\n  $dice_OUT\n\n* Results Available On Clipboard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0h:
tv='txt2sha256sum'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mma0j:
tv='txt2t9'; echo "${tv}: Input Data"; read -r tvi; tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mma0
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mmam:
clear
echo -e "Current Password: $EncMsgPass
== Message En/DeCrypter
 1 | Enter Password (run 1st)
 2 | Encrypt (OpenSSL)
 3 | Decrypt (OpenSSL)
 4 | Encrypt (base64)
 5 | Decrypt (base64)
 6 | txt2hex
 7 | hex2txt
 8 | See Tables
 9 | Make Clip QR
 0 | Read Clip QR
 - | Status
 \ | Exit"
read -rsn1 InKey; echo; InKey=${InKey,,}; clear; case "$InKey" in
'1') jumpto mmam1 ;;
'2') jumpto mmam2 ;;
'3') jumpto mmam3 ;;
'4') jumpto mmam4 ;;
'5') jumpto mmam5 ;;
'6') jumpto mmam6 ;;
'7') jumpto mmam7 ;;
'8') jumpto dastables ;;
'9') jumpto mmam9 ;;
'0') jumpto mmam0 ;;
'-') jumpto mmamm ;;
'\') jumpto mma ;;
  *) jumpto mmam ;;
esac
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mmam1:
EncMsgPass=""; echo -e "Enter password:"; read -r EncMsgPass; EncMsgPass=$(echo -n "$EncMsgPass")
jumpto mmam
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mmam2:
tv='txt2ssl'; echo "${tv}: Input Data (Finish with a new line and Ctrl-D)"; while IFS= read -r line; do tvi="${tvi}${line}"$'\n'; done; tvi=$(echo -n "$tvi"); tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mmam
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mmam3:
tv='ssl2txt'; echo "${tv}: Input Data"; read -r tvi; tvi=$(echo -n "$tvi"); tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mmam
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mmam4:
tv='txt2b64'; echo "${tv}: Input Data (Finish with a new line and Ctrl-D)"; while IFS= read -r line; do tvi="${tvi}${line}"$'\n'; done; tvi=$(echo -n "$tvi"); tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap; jumpto mmam
jumpto mmam
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mmam5:
tv='b642txt'; echo "${tv}: Input Data"; read -r tvi; tvi=$(echo -n "$tvi"); tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mmam
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mmam6:
tv='txt2hex'; echo "${tv}: Input Data (Finish with a new line and Ctrl-D)"; while IFS= read -r line; do tvi="${tvi}${line}"$'\n'; done; tvi=$(echo -n "$tvi"); tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mmam
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mmam7:
tv='hex2txt'; echo "${tv}: Input Data (Finish with a new line and Ctrl-D)"; while IFS= read -r line; do tvi="${tvi}${line}"$'\n'; done; tvi=$(echo -n "$tvi"); tvo=$(${tv} "$tvi"); toclip "$tvo"; echo -e "${tv} (Length= ${#tvo})\n  $tvo\n\n* Results Available On ClipBoard *"; crap
jumpto mmam
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mmam9:
ClipTxtToQr; crap
jumpto mmam
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mmam0:
readclipQR; crap
jumpto mmam
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
mmamm:
EncMsgClip=$(xclip -o -selection clipboard); sleep .1; clear; echo -e "=========Status Report ============\n****Password****\n$EncMsgPass\n---------------------------------------\n****ClipBoard****\n$EncMsgClip\n---------------------------------------\n"; crap
jumpto mmam
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
dastables:
clear
echo $(cat <<'AsciiEOF'
--ASCII TABLE------------------------------------------------------------------------------------------------
 _Dec______Hex_______Binary______B64______Oct______Char______________________________________________________
   0    |  00    |  0000 0000  |  A    |  000    |  NUL (Null)
   1    |  01    |  0000 0001  |  B    |  001    |  SOH (Start of Header)
   2    |  02    |  0000 0010  |  C    |  002    |  STX (Start of Text)
   3    |  03    |  0000 0011  |  D    |  003    |  ETX (End of Text)
   4    |  04    |  0000 0100  |  E    |  004    |  EOT (End of Transmission)
   5    |  05    |  0000 0101  |  F    |  005    |  ENQ (Enquiry)
   6    |  06    |  0000 0110  |  G    |  006    |  ACK (Acknowledgment)
   7    |  07    |  0000 0111  |  H    |  007    |  BEL (Bell)
   8    |  08    |  0000 1000  |  I    |  010    |  BS  (Backspace)
   9    |  09    |  0000 1001  |  J    |  011    |  TAB (Horizontal Tab)
  10    |  0A    |  0000 1010  |  K    |  012    |  LF  (Line Feed)
  11    |  0B    |  0000 1011  |  L    |  013    |  VT  (Vertical Tab)
  12    |  0C    |  0000 1100  |  M    |  014    |  FF  (Form Feed)
  13    |  0D    |  0000 1101  |  N    |  015    |  CR  (Carriage Return)
  14    |  0E    |  0000 1110  |  O    |  016    |  SO  (Shift Out)
  15    |  0F    |  0000 1111  |  P    |  017    |  SI  (Shift In)
  16    |  10    |  0001 0000  |  Q    |  020    |  DLE (Data Link Escape)
  17    |  11    |  0001 0001  |  R    |  021    |  DC1 (Device Control 1)
  18    |  12    |  0001 0010  |  S    |  022    |  DC2 (Device Control 2)
  19    |  13    |  0001 0011  |  T    |  023    |  DC3 (Device Control 3)
  20    |  14    |  0001 0100  |  U    |  024    |  DC4 (Device Control 4)
  21    |  15    |  0001 0101  |  V    |  025    |  NAK (Negative Acknowledgment)
  22    |  16    |  0001 0110  |  W    |  026    |  SYN (Synchronous Idle)
  23    |  17    |  0001 0111  |  X    |  027    |  ETB (End of Transmission Block)
  24    |  18    |  0001 1000  |  Y    |  030    |  CAN (Cancel)
  25    |  19    |  0001 1001  |  Z    |  031    |  EM  (End of Medium)
  26    |  1A    |  0001 1010  |  a    |  032    |  SUB (Substitute)
  27    |  1B    |  0001 1011  |  b    |  033    |  ESC (Escape)
  28    |  1C    |  0001 1100  |  c    |  034    |  FS  (File Separator)
  29    |  1D    |  0001 1101  |  d    |  035    |  GS  (Group Separator)
  30    |  1E    |  0001 1110  |  e    |  036    |  RS  (Record Separator)
  31    |  1F    |  0001 1111  |  f    |  037    |  US  (Unit Separator)
  32    |  20    |  0010 0000  |  g    |  040    |  SPACE
  33    |  21    |  0010 0001  |  h    |  041    |  !
  34    |  22    |  0010 0010  |  i    |  042    |  "
  35    |  23    |  0010 0011  |  j    |  043    |  #
  36    |  24    |  0010 0100  |  k    |  044    |  $
  37    |  25    |  0010 0101  |  l    |  045    |  %
  38    |  26    |  0010 0110  |  m    |  046    |  &
  39    |  27    |  0010 0111  |  n    |  047    |  '
  40    |  28    |  0010 1000  |  o    |  050    |  (
  41    |  29    |  0010 1001  |  p    |  051    |  )
  42    |  2A    |  0010 1010  |  q    |  052    |  *
  43    |  2B    |  0010 1011  |  r    |  053    |  +
  44    |  2C    |  0010 1100  |  s    |  054    |  ,
  45    |  2D    |  0010 1101  |  t    |  055    |  -
  46    |  2E    |  0010 1110  |  u    |  056    |  .
  47    |  2F    |  0010 1111  |  v    |  057    |  /
  48    |  30    |  0011 0000  |  w    |  060    |  0
  49    |  31    |  0011 0001  |  x    |  061    |  1
  50    |  32    |  0011 0010  |  2    |  062    |  2
  51    |  33    |  0011 0011  |  3    |  063    |  3
  52    |  34    |  0011 0100  |  4    |  064    |  4
  53    |  35    |  0011 0101  |  5    |  065    |  5
  54    |  36    |  0011 0110  |  6    |  066    |  6
  55    |  37    |  0011 0111  |  7    |  067    |  7
  56    |  38    |  0011 1000  |  8    |  070    |  8
  57    |  39    |  0011 1001  |  9    |  071    |  9
  58    |  3A    |  0011 1010  |  :    |  072    |  :
  59    |  3B    |  0011 1011  |  ;    |  073    |  ;
  60    |  3C    |  0011 1100  |  <    |  074    |  <
  61    |  3D    |  0011 1101  |  =    |  075    |  =
  62    |  3E    |  0011 1110  |  >    |  076    |  >
  63    |  3F    |  0011 1111  |  ?    |  077    |  ?
  64    |  40    |  0100 0000  |  @    |  100    |  @
  65    |  41    |  0100 0001  |  A    |  101    |  A
  66    |  42    |  0100 0010  |  B    |  102    |  B
  67    |  43    |  0100 0011  |  C    |  103    |  C
  68    |  44    |  0100 0100  |  D    |  104    |  D
  69    |  45    |  0100 0101  |  E    |  105    |  E
  70    |  46    |  0100 0110  |  F    |  106    |  F
  71    |  47    |  0100 0111  |  G    |  107    |  G
  72    |  48    |  0100 1000  |  H    |  110    |  H
  73    |  49    |  0100 1001  |  I    |  111    |  I
  74    |  4A    |  0100 1010  |  J    |  112    |  J
  75    |  4B    |  0100 1011  |  K    |  113    |  K
  76    |  4C    |  0100 1100  |  L    |  114    |  L
  77    |  4D    |  0100 1101  |  M    |  115    |  M
  78    |  4E    |  0100 1110  |  N    |  116    |  N
  79    |  4F    |  0100 1111  |  O    |  117    |  O
  80    |  50    |  0101 0000  |  P    |  120    |  P
  81    |  51    |  0101 0001  |  Q    |  121    |  Q
  82    |  52    |  0101 0010  |  R    |  122    |  R
  83    |  53    |  0101 0011  |  S    |  123    |  S
  84    |  54    |  0101 0100  |  T    |  124    |  T
  85    |  55    |  0101 0101  |  U    |  125    |  U
  86    |  56    |  0101 0110  |  V    |  126    |  V
  87    |  57    |  0101 0111  |  W    |  127    |  W
  88    |  58    |  0101 1000  |  X    |  130    |  X
  89    |  59    |  0101 1001  |  Y    |  131    |  Y
  90    |  5A    |  0101 1010  |  Z    |  132    |  Z
  91    |  5B    |  0101 1011  |  [    |  133    |  [
  92    |  5C    |  0101 1100  |  \    |  134    |  \
  93    |  5D    |  0101 1101  |  ]    |  135    |  ]
  94    |  5E    |  0101 1110  |  ^    |  136    |  ^
  95    |  5F    |  0101 1111  |  _    |  137    |  _
  96    |  60    |  0110 0000  |  \`   |  140    |  `
  97    |  61    |  0110 0001  |  a    |  141    |  a
  98    |  62    |  0110 0010  |  b    |  142    |  b
  99    |  63    |  0110 0011  |  c    |  143    |  c
 100    |  64    |  0110 0100  |  d    |  144    |  d
 101    |  65    |  0110 0101  |  e    |  145    |  e
 102    |  66    |  0110 0110  |  f    |  146    |  f
 103    |  67    |  0110 0111  |  g    |  147    |  g
 104    |  68    |  0110 1000  |  h    |  150    |  h
 105    |  69    |  0110 1001  |  i    |  151    |  i
 106    |  6A    |  0110 1010  |  j    |  152    |  j
 107    |  6B    |  0110 1011  |  k    |  153    |  k
 108    |  6C    |  0110 1100  |  l    |  154    |  l
 109    |  6D    |  0110 1101  |  m    |  155    |  m
 110    |  6E    |  0110 1110  |  n    |  156    |  n
 111    |  6F    |  0110 1111  |  o    |  157    |  o
 112    |  70    |  0111 0000  |  p    |  160    |  p
 113    |  71    |  0111 0001  |  q    |  161    |  q
 114    |  72    |  0111 0010  |  r    |  162    |  r
 115    |  73    |  0111 0011  |  s    |  163    |  s
 116    |  74    |  0111 0100  |  t    |  164    |  t
 117    |  75    |  0111 0101  |  u    |  165    |  u
 118    |  76    |  0111 0110  |  v    |  166    |  v
 119    |  77    |  0111 0111  |  w    |  167    |  w
 120    |  78    |  0111 1000  |  x    |  170    |  x
 121    |  79    |  0111 1001  |  y    |  171    |  y
 122    |  7A    |  0111 1010  |  z    |  172    |  z
 123    |  7B    |  0111 1011  |  {    |  173    |  {
 124    |  7C    |  0111 1100  |  |    |  174    |  |
 125    |  7D    |  0111 1101  |  }    |  175    |  }
 126    |  7E    |  0111 1110  |  ~    |  176    |  ~
 127    |  7F    |  0111 1111  |  DEL  |  177    |  DEL (Delete)

===============================================================================

*Points On Elliptical Curve* (78 chars)
115792089237316195423570985008687907852837564279074904382605163141518161494337

*Largest (DEC)* (78 chars)
115792089237316195423570985008687907852837564279074904382605163141518161494336

*Largest (BIN)* (256 chars)
1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111010111010101011101101110011100110101011110100100010100000001110111011111111010010010111101000110011010000001101100100000101000000

*Largest (HEX)* (64 chars)
fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140

===============================================================================
AsciiEOF
)
crap
jumpto mma

#---------------------------------------------------------------------------------------------------------------------------------------------------------------

readme:
echo '
# Bitcoin Key Management Tool

This Bash script provides a suite of tools for Bitcoin key management and conversion. It includes functionalities for generating new keys, converting keys between different formats, creating and reading QR codes, and copying data to and from the clipboard.

## Features

- Convert a 64-character hexadecimal private key to a Wallet Import Format (WIF) key.
- Convert WIF back to a 64-character hexadecimal private key.
- Generate a new random 64-character hexadecimal private key.
- Convert a 64-character hexadecimal private key to a Bitcoin address.
- Create QR codes from text and read QR codes to text, handling clipboard operations.

### Installing Dependencies

======= Recommended To Have As Dependencies ============
##--- LINUX DEPS ---##
sudo apt install -y base58 basez dc espeak feh festival figlet flite gifsicle gnupg hashalot imagemagick img2pdf jp2a jpegoptim jq minimodem oathtool openssl pandoc pngcrush python3 python3-pip qrencode ruby-ascii85 sox speech-dispatcher tesseract-ocr webcamoid webp whiptail wkhtmltopdf xautomation xbindkeys xclip xdotool yad zbar-tools zenity zint-qt

##--- PYTHON DEPS (opion 1)---##
pip3 install base58 ecdsa mnemonic pycryptodome pyperclip qrcode

##--- PYTHON DEPS (opion 2)---##
sudo apt install -y python3-base58 python3-ecdsa python3-mnemonic python3-pycryptodome python3-pyperclip python3-qrcode

'
crap; jumpto mma
#---------------------------------------------------------------------------------------------------------------------------------------------------------------

#################### END ####################
