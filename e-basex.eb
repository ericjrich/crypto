#!/usr/bin/env bash
#20231112_21:39_est--EJR
#BaseX EJR (migrated from python to bash)

#===========================================================================================================================
pf1() {
local arg1="$1"
local pycode=$(cat <<PYEOF
#!/usr/bin/env python3
#base64 private key to others
#20230815_1549_(est) EJR
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
import os, pyperclip, hashlib, base58, secrets, qrcode, subprocess, sys
from Crypto.Hash import RIPEMD160
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
# Secp256k1 Curve Parameters
a = 0
b = 7
p = 2 ** 256 - 2 ** 32 - 2 ** 9 - 2 ** 8 - 2 ** 7 - 2 ** 6 - 2 ** 4 - 1
n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
g = {
  'x': 55066263022277343669578718895168534326250603453777594175500187360389116729240,
  'y': 32670510020758816978083085130507043184471273380659243275938904335757337482424
}
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
# Elliptic Curve Mathematics
def modinv(a, m = p):
    a = a % m if a < 0 else a
    prevy, y = 0, 1
    while a > 1:
        q = m // a
        y, prevy = prevy - q * y, y
        a, m = m % a, a
    return y
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
def double(point):
    slope = ((3 * point['x'] ** 2) * modinv((2 * point['y']))) % p
    x = (slope ** 2 - (2 * point['x'])) % p
    y = (slope * (point['x'] - x) - point['y']) % p
    return {'x': x, 'y': y}
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
def add(point1, point2):
    if point1 == point2:
        return double(point1)
    slope = ((point1['y'] - point2['y']) * modinv(point1['x'] - point2['x'])) % p
    x = (slope ** 2 - point1['x'] - point2['x']) % p
    y = ((slope * (point1['x'] - x)) - point1['y']) % p
    return {'x': x, 'y': y}
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
def multiply(k, point = g):
    current = point
    binary = format(k, 'b')[1:]
    for char in binary:
        current = double(current)
        if char == '1':
            current = add(current, point)
    return current
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
# Convert Private Key to WIF
def private_key_to_wif(private_key_hex):
    extended = "80" + private_key_hex + "01"
    checksum = hashlib.sha256(hashlib.sha256(bytes.fromhex(extended)).digest()).digest()[:4]
    extended_checksum = extended + checksum.hex()
    wif = base58.b58encode(bytes.fromhex(extended_checksum)).decode()
    return wif
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
# Hash160 Public Key Function
def hash160(data):
    # Convert hexadecimal string to byte sequence first
    binary = bytes.fromhex(data)

    # SHA-256
    sha256 = hashlib.sha256(binary).digest()

    # RIPEMD-160
    ripemd160 = RIPEMD160.new()
    ripemd160.update(sha256)
    hash160_bytes = ripemd160.digest()

    # Convert from byte sequence back to hexadecimal
    hash160_hex = hash160_bytes.hex()

    return hash160_hex
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
# Get user input for private key or generation option
choice = sys.argv[1]
if choice == '1':
    prvkeyhex = input()
    if len(prvkeyhex) != 64:
        print("Invalid private key length.")
        exit()
elif choice == '2':
    # Generate a random 32-byte private key
    prvkeybytes = secrets.token_bytes(32)
    prvkeyhex = prvkeybytes.hex()
else:
    print("Invalid choice.")
    exit()
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
# Convert private key to bytes
prvkeybytes = bytes.fromhex(prvkeyhex)
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
# Generate public key from private key
prvkeyint = int.from_bytes(prvkeybytes, byteorder="big")
point = multiply(prvkeyint)
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
# Convert x and y values of the public key point to hexadecimal
x = format(point['x'], '064x')
y = format(point['y'], '064x')
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
# Compressed public key
prefix = '02' if point['y'] % 2 == 0 else '03'
pubkeyhex = prefix + x
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
# Hash160 of the public key
pubkey_hash160 = hash160(pubkeyhex) # Step 1
versioned_hash = '00' + pubkey_hash160  # Step 2
checksum = hashlib.sha256(hashlib.sha256(bytes.fromhex(versioned_hash)).digest()).digest()[:4]  # Step 3
final_address = versioned_hash + checksum.hex()  # Step 4
public_address = base58.b58encode(bytes.fromhex(final_address)).decode()  # Step 5
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
# Convert Private Key to WIF
wif = private_key_to_wif(prvkeyhex)
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .


# VARS
# OLD CODE:   print(prvkeyhex, wif, pubkeyhex, pubkey_hash160, public_address, flush=True)
print(f"{prvkeyhex}|{wif}|{pubkeyhex}|{pubkey_hash160}|{public_address}", flush=True)

PYEOF
)
# OLD CODE:   local output=$(python3 -c "$pycode" "$arg1"); read -r prvkeyhex wif pubkeyhex pubkey_hash160 public_address <<< "$output"
local output=$(python3 -c "$pycode" "$arg1"); IFS='|' read -r prvkeyhex wif pubkeyhex pubkey_hash160 public_address <<< "$output"

}
#===========================================================================================================================
## MORE FUCTIONS ##########################################
  jumpto() { local LV1=$1; local LV2=$(sed -n "/$LV1:/{:a;n;p;ba};" $0 | grep -v ':$'); sleep .1; eval "$LV2"; exit; }
  crap() { read -n 1 -p '*ANY-KEY*'; echo; }
  install_deps() { for i in "${deps_apt[@]}"; do if ! dpkg -l | grep -q "^ii  $i "; then echo "Installing $i..."; sudo apt install -y "$i"; else echo "$i is already installed."; fi; done; for i in "${deps_pip3[@]}"; do if ! pip3 show "$i" &> /dev/null; then echo "Installing $i..."; pip3 install "$i"; else echo "$i is already installed."; fi; done; }
  savetofile() {
    echo 'saving.......'; touch $basexfile; echo '_______________________________________________________________________________________________________________________' >>$basexfile; echo '~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~' >>$basexfile; echo >>$basexfile; echo "Private Key: $prvkeyhex" >>$basexfile; qrencode -t ASCIIi $prvkeyhex >>$basexfile; echo >>$basexfile; echo "WIF: $wif" >>$basexfile; qrencode -t ASCIIi "$wif" >>$basexfile; echo >>$basexfile; echo "Public Key: $pubkeyhex" >>$basexfile; qrencode -t ASCIIi "$pubkeyhex" >>$basexfile; echo >>$basexfile; echo "Public Key Hash160: $pubkey_hash160" >>$basexfile; qrencode -t ASCIIi "$pubkey_hash160" >>$basexfile; echo >>$basexfile; echo "Public Address: $public_address" >>$basexfile; qrencode -t ASCIIi "$public_address" >>$basexfile
    echo "**** Saved In File: $basexfile ****"
  }
  showinterminal() {
    clear; echo
    echo "Private Key: $prvkeyhex"; qrencode -t ASCIIi $prvkeyhex; echo
    echo "WIF: $wif"; qrencode -t ASCIIi "$wif"; echo
    echo "Public Key: $pubkeyhex"; qrencode -t ASCIIi "$pubkeyhex"; echo
    echo "Public Key Hash160: $pubkey_hash160"; qrencode -t ASCIIi "$pubkey_hash160"; echo
    echo "Public Address: $public_address"; qrencode -t ASCIIi "$public_address"; public_address_url="https://mempool.space/address/$public_address"; echo -n "$public_address_url" | xclip -selection clipboard
    echo 'Mempool Link In ClipBoard'
  }
## VARS ###################################################
  basexfile="$HOME/Desktop/basex.txt"
  deps_apt=(python3-pip qrencode xclip) # FUTURE?: (base58 basez gnupg imagemagick oathtool openssl ruby-ascii85 tesseract-ocr zbar-tools)
  deps_pip3=(mnemonic ecdsa pycryptodome pyperclip qrcode base58)

## MAIN MENU a ############################################
mma:
  clear
  echo '(1) Enter Private Key'
  echo '(2) Generate New Private Key'
  echo '(3) Dependency Installer'
  echo '(4) Mnemonic Generator via private key ..REQUIRES A PRIVATE KEY..'
  echo '(\) EXIT'; read -rsn1 inkey; echo; inkey=${inkey,,}; clear; case "$inkey" in
  ### CASES #########
  '1') echo 'Enter Private Key:'; pf1 '1';;
  '2') pf1 '2';;
  '3') install_deps; crap; jumpto mma;;
  '4') jumpto mma4;;
  '\') exit 0;; *) jumpto mma;; esac; jumpto mmb
## MAIN MENU b ############################################
mmb:
  clear
  echo '(1) See Output'
  echo "(2) See Output AND Save To $basexfile"
  echo "(3) Just Save To $basexfile"
  echo "(4) Delete $basexfile"
  echo '(\) Back To Main Menu'; read -rsn1 inkey; echo; inkey=${inkey,,}; clear; case "$inkey" in
  ### CASES #########
  '1') showinterminal;;
  '2') savetofile; showinterminal;;
  '3') savetofile;;
  '4') rm "$basexfile";;
  '\') jumpto mma;; *) jumpto mmb;; esac; crap; jumpto mmb
#===========================================================================================================================
mma4:
#20231114_21:42_est--EJR
#=== example =================================================================
# Phrase maker for private key that are 64 character base64 number
# Private key (hex):
#  ef235aacf90d9f4aadd8c92e4b2562e1d9eb97f0df9ba3b508258739cb013db2
# Entropy:
#  1110111100100011010110101010110011111001000011011001111101001010101011011101100011001001001011100100101100100101011000101110000111011001111010111001011111110000110111111001101110100011101101010000100000100101100001110011100111001011000000010011110110110010
# Checksum:
#  01100000
# Full Seed (binary):
#  111011110010001101011010101011001111100100001101100111110100101010101101110110001100100100101110010010110010010101100010111000011101100111101011100101111111000011011111100110111010001110110101000010000010010110000111001110011100101100000001001111011011001001100000
# ==== Your seed phrase is ====
#  upset bracket private velvet supreme pipe resist bomb comic float flavor senior pact slogan sell vibrant photo portion annual attack original letter walnut equal
#=============================================================================
# VARS
  txt_nums="/tmp/numbers.txt"
  txt_seed="/tmp/seed_phrase.txt"

# FUNCS
  hex_to_bin() {
      local hex=$1
      for (( i=0; i<${#hex}; i++ )); do
          case ${hex:$i:1} in
              0) echo -n "0000" ;;
              1) echo -n "0001" ;;
              2) echo -n "0010" ;;
              3) echo -n "0011" ;;
              4) echo -n "0100" ;;
              5) echo -n "0101" ;;
              6) echo -n "0110" ;;
              7) echo -n "0111" ;;
              8) echo -n "1000" ;;
              9) echo -n "1001" ;;
              A|a) echo -n "1010" ;;
              B|b) echo -n "1011" ;;
              C|c) echo -n "1100" ;;
              D|d) echo -n "1101" ;;
              E|e) echo -n "1110" ;;
              F|f) echo -n "1111" ;;
          esac
      done
  }

  sha256() { echo -n $1 | shasum -a 256 -0; }

# begin
  clear
  echo -e "==== Welcome To Mnemonic Generator (work in progress / new feature) ====\n\nIT IS REQUIRED TO HAVE THE WORD LIST SAVED AT:\n"
  echo -e "\t ~/a-me/z-share/code/bitwords.txt\n"; crap
# Read the hexadecimal key
  clear
  echo "Enter your 64-character hexadecimal key:"; read hex_key
# Convert hex to binary
  entropy=$(hex_to_bin $hex_key)
# Calculate SHA-256 checksum
  checksum=$(sha256 $entropy | awk '{print $1}' | cut -c1-2)
# Append checksum to entropy
  checksum_bin=$(hex_to_bin $checksum)
  entropy_checksum=$entropy$checksum_bin
# Split into 11-bit groups and convert to numbers
  for (( i=0; i<${#entropy_checksum}; i+=11 )); do
    binary_group=${entropy_checksum:$i:11}
    echo $((2#${binary_group} + 1))
  done > "$txt_nums"
# Convert numbers to words using wordlist
  while read number; do
    sed -n "${number}p" "$HOME/a-me/z-share/code/bitwords.txt"
  done < "$txt_nums" > "$txt_seed"

# SHOW OUTPUTS ------------------------------------------------------------
echo -e "Entropy:\n $entropy"
echo -e "Checksum:\n $(hex_to_bin $checksum)"
echo -e "Full Seed (binary):\n $entropy_checksum"
echo "==== Your seed phrase is ===="; cat "$txt_seed"; echo '-------------------------------------------'
echo -e "\nPLEASE RECORD THIS INFO MANUALLY\n IT WILL DISSAPPEAR WHEN YOU LEAVE\nHit Enter When Ready"; read junk; sleep 1; crap

jumpto mma
#...............................