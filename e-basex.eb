#!/usr/bin/env bash
#20231215_16:39_est--EJR
#BaseX EJR (migrated from python to bash)
#
#== FUNCTIONS ==============================================================================================================
# == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == ==
pf1() {
local arg1="$1"
local pycode=$(cat <<PYEOF
#!/usr/bin/env python3

import os, pyperclip, hashlib, base58, secrets, qrcode, subprocess, sys
from Crypto.Hash import RIPEMD160

# Secp256k1 Curve Parameters
a, b, p, n = 0, 7, 2**256 - 2**32 - 2**9 - 2**8 - 2**7 - 2**6 - 2**4 - 1, 115792089237316195423570985008687907852837564279074904382605163141518161494337
g = {'x': 55066263022277343669578718895168534326250603453777594175500187360389116729240, 'y': 32670510020758816978083085130507043184471273380659243275938904335757337482424}

#= FUNCTIONS ====================================
def modinv(a, m = p):
  a = a % m if a < 0 else a; prevy, y = 0, 1
  while a > 1:
    q = m // a; y, prevy = prevy - q * y, y; a, m = m % a, a
  return y

def double(point):
  slope = ((3 * point['x'] ** 2) * modinv((2 * point['y']))) % p; x = (slope ** 2 - (2 * point['x'])) % p; y = (slope * (point['x'] - x) - point['y']) % p
  return {'x': x, 'y': y}

def add(point1, point2):
  if point1 == point2:
    return double(point1)
  slope = ((point1['y'] - point2['y']) * modinv(point1['x'] - point2['x'])) % p; x = (slope ** 2 - point1['x'] - point2['x']) % p; y = ((slope * (point1['x'] - x)) - point1['y']) % p
  return {'x': x, 'y': y}

def multiply(k, point = g):
  current = point; binary = format(k, 'b')[1:]
  for char in binary:
    current = double(current)
    if char == '1':
      current = add(current, point)
  return current

def private_key_to_wif(private_key_hex):
  extended = "80" + private_key_hex + "01"; checksum = hashlib.sha256(hashlib.sha256(bytes.fromhex(extended)).digest()).digest()[:4]; extended_checksum = extended + checksum.hex(); wif = base58.b58encode(bytes.fromhex(extended_checksum)).decode()
  return wif

def hash160(data):
  binary = bytes.fromhex(data); sha256 = hashlib.sha256(binary).digest(); ripemd160 = RIPEMD160.new(); ripemd160.update(sha256); hash160_bytes = ripemd160.digest(); hash160_hex = hash160_bytes.hex()
  return hash160_hex

#= User Choice (1=User Input Key / 2=Gen. Key) ==
choice = sys.argv[1]
if choice == '1':
  prvkeyhex = input()
  if len(prvkeyhex) != 64:
    print("Invalid private key length."); exit()
elif choice == '2':
  prvkeybytes = secrets.token_bytes(32); prvkeyhex = prvkeybytes.hex()
else:
  print("Invalid choice."); exit()

#= PrivateKey to bytes ==========================
prvkeybytes = bytes.fromhex(prvkeyhex)

#= PrivateKey To PublicKey ======================
prvkeyint = int.from_bytes(prvkeybytes, byteorder="big"); point = multiply(prvkeyint)

#= Pubic(x,y) to hex ============================
x = format(point['x'], '064x'); y = format(point['y'], '064x')

#= Compressed public key ========================
prefix = '02' if point['y'] % 2 == 0 else '03'; pubkeyhex = prefix + x

#= Hash160 of the public key ====================
pubkey_hash160 = hash160(pubkeyhex); versioned_hash = '00' + pubkey_hash160; checksum = hashlib.sha256(hashlib.sha256(bytes.fromhex(versioned_hash)).digest()).digest()[:4]; final_address = versioned_hash + checksum.hex(); public_address = base58.b58encode(bytes.fromhex(final_address)).decode()

#= Private Key to WIF ===========================
wif = private_key_to_wif(prvkeyhex)

#= VARS =========================================
print(f"{prvkeyhex}|{wif}|{pubkeyhex}|{pubkey_hash160}|{public_address}", flush=True)
PYEOF
)
local output=$(python3 -c "$pycode" "$arg1") # RUN THE PYTHON CODE TO FETCH VARS
IFS='|' read -r prvkeyhex wif pubkeyhex pubkey_hash160 public_address <<< "$output" # IMPORT THE VARS IN A MEANINGFUL WAY FOR BASH USE
}
# == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == ==
# == == == == == == == == == == == == == == == == == ==
jumpto() { local LV1=$1; local LV2=$(sed -n "/$LV1:/{:a;n;p;ba};" $0 | grep -v ':$'); sleep .1; eval "$LV2"; exit; }
crap() { read -n 1 -p '*ANY-KEY*'; echo; }
install_deps() { for i in "${deps_apt[@]}"; do if ! dpkg -l | grep -q "^ii  $i "; then echo "Installing $i..."; sudo apt install -y "$i"; else echo "$i is already installed."; fi; done; for i in "${deps_pip3[@]}"; do if ! pip3 show "$i" &> /dev/null; then echo "Installing $i..."; pip3 install "$i"; else echo "$i is already installed."; fi; done; }
# == == == == == == == == == == == == == == == == == ==
savetofile() {
  touch "$file_numbers"; > "$file_numbers"
  touch "$file_phrase"; > "$file_phrase"
  local toline_number
  local tonm1="$prvkeyhex" #~~Get 64 char hex string as $tonm1
  local tonm2=$(hex2bin $tonm1) #~~Convert $tonm1 (64 char hex string) to binary as $tonm2
  local tonm3=$(sha_256 $tonm2 | awk '{print $1}' | cut -c1-2) #~~Get sha256sum of $tonm2 & only record the 1st two chars of the output as $tonm3
  local tonm4=$(hex2bin $tonm3) #~~Convert $tonm3 (our 2 chars of hex) to binary as $tonm4
  local tonm5=$tonm2$tonm4 #~~Append our $tonm4 (this is the checksum) to $tonm2 (orignal string in binary) | this forms a binary that we can use to make our phrase
  #~~Split $tonm5 into 11-bit groups & convert to numbers (which are output to $file_numbers)
  for (( i=0; i<${#tonm5}; i+=11 )); do
    tonm6=${tonm5:$i:11}
    echo $((2#${tonm6}))
  done > "$file_numbers"
  #~~Convert our numbers from $file_numbers to words using $bitwords (wordlist) and output the result to $file_phrase
  while read toline_number; do
    toline_number=$((toline_number + 1))
    sed -n "${toline_number}p" "$bitwords"
  done < "$file_numbers" > "$file_phrase"
#--------------------------------------------
  local public_address_url="https://mempool.space/address/$public_address"; echo 'saving.......'; touch $basexfile
  echo -e "############ $(date -u '+%Y-%m-%d %H:%M:%S') UTC     ||     $(date '+%Y-%m-%d %H:%M:%S') LOCAL #############\n" >>$basexfile
  qrencode -t ASCIIi $prvkeyhex >>$basexfile; echo -e "\n⬆️Private Key⬆️\n" >>$basexfile
  qrencode -t ASCIIi "$wif" >>$basexfile; echo -e "\n⬆️WIF⬆️\n" >>$basexfile
  qrencode -t ASCIIi "$pubkeyhex" >>$basexfile; echo -e "\n⬆️Public Key⬆️\n" >>$basexfile
  qrencode -t ASCIIi "$pubkey_hash160" >>$basexfile; echo -e "\n⬆️Public Key Hash160⬆️\n" >>$basexfile
  qrencode -t ASCIIi "$public_address" >>$basexfile; echo -e "\n⬆️Address⬆️\n" >>$basexfile
  qrencode -t ASCIIi "$public_address_url" >>$basexfile; echo -e "\n⬆️URL (Bal)⬆️\n" >>$basexfile
  echo -e "Private Key:\n $prvkeyhex\n\nWIF:\n $wif\n\nPublic Key:\n $pubkeyhex\n\nPublic Key Hash160:\n $pubkey_hash160\n\nPublic Address:\n $public_address\n\nURL (Bal):\n $public_address_url
-----------------------------------------
Entropy (bin):\n $tonm2
Checksum:\n hex=$tonm3\n bin=$tonm4
Entropy w/ Checksum (bin):\n $tonm5\n

==== Your seed phrase is ====" >>$basexfile
  cat "$file_phrase" >>$basexfile; echo '............................................' >>$basexfile
  echo "**** Saved In File: $basexfile ****"
}
# == == == == == == == == == == == == == == == == == ==
showinterminal() {
  clear; echo
  #~~~~~~~~~~~~~~~~~
  # vars & files
  touch "$file_numbers"; > "$file_numbers"
  touch "$file_phrase"; > "$file_phrase"
  local toline_number
  local tonm1="$prvkeyhex" #~~Get 64 char hex string as $tonm1
  local tonm2=$(hex2bin $tonm1) #~~Convert $tonm1 (64 char hex string) to binary as $tonm2
  local tonm3=$(sha_256 $tonm2 | awk '{print $1}' | cut -c1-2) #~~Get sha256sum of $tonm2 & only record the 1st two chars of the output as $tonm3
  local tonm4=$(hex2bin $tonm3) #~~Convert $tonm3 (our 2 chars of hex) to binary as $tonm4
  local tonm5=$tonm2$tonm4 #~~Append our $tonm4 (this is the checksum) to $tonm2 (orignal string in binary) | this forms a binary that we can use to make our phrase
  #~~Split $tonm5 into 11-bit groups & convert to numbers (which are output to $file_numbers)
  for (( i=0; i<${#tonm5}; i+=11 )); do
    tonm6=${tonm5:$i:11}
    echo $((2#${tonm6}))
  done > "$file_numbers"
  #~~Convert our numbers from $file_numbers to words using $bitwords (wordlist) and output the result to $file_phrase
  while read toline_number; do
    toline_number=$((toline_number + 1))
    sed -n "${toline_number}p" "$bitwords"
  done < "$file_numbers" > "$file_phrase"
#-----------------------------------------------
  local public_address_url="https://mempool.space/address/$public_address"
  echo -n "$public_address_url" | xclip -selection clipboard
  #~~~~~~~~~~~~~~~~~
  echo '=============== QR CODES =================='
  qrencode -t ASCIIi $prvkeyhex; echo -e "\n⬆️ Private Key⬆️\n"
  qrencode -t ASCIIi "$wif"; echo -e "\n⬆️ WIF⬆️\n"
  qrencode -t ASCIIi "$pubkeyhex"; echo -e "\n⬆️ Public Key⬆️\n"
  qrencode -t ASCIIi "$pubkey_hash160"; echo -e "\n⬆️ Public Key Hash160⬆️\n"
  qrencode -t ASCIIi "$public_address"; echo -e "\n⬆️ Address⬆️\n"
  qrencode -t ASCIIi "$public_address_url"; echo -e "\n⬆️ URL (Bal)⬆️\n"
  #~~~~~~~~~~~~~~~~~
  echo -e "Private Key:\n $prvkeyhex\n\nWIF:\n $wif\n\nPublic Key:\n $pubkeyhex\n\nPublic Key Hash160:\n $pubkey_hash160\n\nAddress:\n $public_address\n\nURL (Bal) [On Clipboard]:\n $public_address_url
-----------------------------------------
Entropy (bin):\n $tonm2
Checksum:\n hex=$tonm3\n bin=$tonm4
Entropy w/ Checksum (bin):\n $tonm5\n

==== Your seed phrase is ===="
  cat "$file_phrase"; echo '............................................'
}
# == == == == == == == == == == == == == == == == == ==
sha_256() { echo -n $1 | shasum -a 256 -0; }
toclip() { echo -n "$1" | xclip -selection clipboard; }
# == == == == == == == == == == == == == == == == == ==
hex2bin() {
  local hex=$1
  for ((i=0; i<${#hex}; i++)); do
    case ${hex:$i:1} in
      0) echo -n "0000" ;;
      1) echo -n "0001" ;;
      2) echo -n "0010" ;;
      3) echo -n "0011" ;;
      4) echo -n "0100" ;;
      5) echo -n "0101" ;;
      6) echo -n "0110" ;;
      7) echo -n "0111" ;;
      8) echo -n "1000" ;;
      9) echo -n "1001" ;;
      [Aa]) echo -n "1010" ;;
      [Bb]) echo -n "1011" ;;
      [Cc]) echo -n "1100" ;;
      [Dd]) echo -n "1101" ;;
      [Ee]) echo -n "1110" ;;
      [Ff]) echo -n "1111" ;;
    esac
  done
}
# == == == == == == == == == == == == == == == == == ==
bin2hex() {
  local bin="$1"
  local hex=""
  while (( (i + ${#bin}) % 4 != 0 )); do bin="0$bin"; done
  for ((i = 0; i < ${#bin}; i += 4)); do
    chunk="${bin:i:4}"
    case "$chunk" in
      0000) hex+="0" ;;
      0001) hex+="1" ;;
      0010) hex+="2" ;;
      0011) hex+="3" ;;
      0100) hex+="4" ;;
      0101) hex+="5" ;;
      0110) hex+="6" ;;
      0111) hex+="7" ;;
      1000) hex+="8" ;;
      1001) hex+="9" ;;
      1010) hex+="a" ;;
      1011) hex+="b" ;;
      1100) hex+="c" ;;
      1101) hex+="d" ;;
      1110) hex+="e" ;;
      1111) hex+="f" ;;
      *) echo "Invalid binary input: $chunk"; return 1 ;;
    esac
  done
  echo "$hex"
}
# == == == == == == == == == == == == == == == == == ==
bin2dec() { local bin="$1"; local dec=""; dec=$(echo "ibase=2; $bin" | bc | tr -d '\n\\'); echo "$dec"; }
dec2bin() { local dec="$1"; local hex=$(dec2hex "$dec"); local bin=$(hex2bin "$hex"); echo "$bin"; }
dec2hex() { local dec="$1"; local hex=""; hex=$(echo "ibase=10; obase=16; $dec" | bc); echo "${hex,,}"; }
hex2dec() { local hex="$1"; local bin=$(hex2bin "$hex"); local dec=$(bin2dec "$bin"); echo "$dec"; }
# == == == == == == == == == == == == == == == == == ==
wif2prv() {
  local IN="$1"
  local OUT
  OUT=$(echo -n "$IN" | base58 -d | xxd -p | tr -d '\n\\') # Decode from base58
  OUT=${OUT,,}
  OUT=${OUT:2} # Trim off the first 2 characters
  OUT=${OUT:0:64} # Crop to 64 characters from the beginning
  echo "$OUT"
}
# == == == == == == == == == == == == == == == == == ==
hex2b6() {
  local IN=$(echo "$1" | rev)
  local dec=$(hex2dec "$IN")
  local base6_number=$(echo "obase=6; $dec" | bc | tr -d '\n\\')
  echo "$base6_number"
}
# == == == == == == == == == == == == == == == == == ==
b62hex() {
  local base6="$1"
  local result=$(echo "obase=16; ibase=6; $base6" | bc | tr -d '\n\\')
  result=${result,,}
  echo "$result"
}
# == == == == == == == == == == == == == == == == == ==
dice() {
  local result=""
  local roll=""
  for ((i = 1; i <= 99; i++)); do
    clear
    echo -e "Roll #$i (Last Roll Was=$roll)\nCurrent Results=$result\nRoll The Dice and Enter The Value\n[1-5 are normal 6=0]"; read -rsn1 roll
    result="${result}${roll}"
  done
  echo "$result"
  dice_OUT="$result"
}
# == == == == == == == == == == == == == == == == == ==

#===========================================================================================================================
#== VARS ===================================================================================================================
basexfile="$HOME/Desktop/basex.txt"
deps_apt=(python3-pip qrencode xclip) # FUTURE?: (base58 basez gnupg imagemagick oathtool openssl ruby-ascii85 tesseract-ocr zbar-tools)
deps_pip3=(mnemonic ecdsa pycryptodome pyperclip qrcode base58)
file_numbers="/tmp/numbers.txt"
file_phrase="/tmp/seed_phrase.txt"
bitwords="$HOME/a-me/z-share/code/bitwords.txt"
#== VARS END ===============================================================================================================
#===========================================================================================================================

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
## MAIN MENU a ############################################
mma:
clear
echo '(1) Enter Private Key'
echo '(2) Generate New Private Key'
echo '(3) Dependency Installer'
echo '(4) Mnemonic Generator via private key ..REQUIRES A PRIVATE KEY..'
echo '(5) Mnemonic 2 Private Key             ..REQUIRES MNEMONIC..'
echo '(6) Base Converter Calculators'
echo '(\) EXIT'; read -rsn1 inkey; echo; inkey=${inkey,,}; clear; case "$inkey" in
### CASES #########
'1') echo 'Enter Private Key:'; pf1 '1';;
'2') pf1 '2';;
'3') install_deps; crap; jumpto mma;;
'4') jumpto mma4;;
'5') jumpto mma5;;
'6') jumpto mma6;;
'\') exit 0;; *) jumpto mma;; esac; jumpto mmb
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
## MAIN MENU b ############################################
mmb:
clear
echo '(1) See Output'
echo "(2) See Output AND Save To $basexfile"
echo "(3) Just Save To $basexfile"
echo "(4) Delete $basexfile"
echo '(\) Back To Main Menu'; read -rsn1 inkey; echo; inkey=${inkey,,}; clear; case "$inkey" in
### CASES #########
'1') showinterminal;;
'2') savetofile; showinterminal;;
'3') savetofile;;
'4') rm "$basexfile";;
'\') jumpto mma;; *) jumpto mmb;; esac; crap; jumpto mmb
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma4:
  # INFO
    clear; echo -e "===================== Welcome To Mnemonic Generator ====================================\n  FYI: (it is required to have the word list saved @ ~/a-me/z-share/code/bitwords.txt\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n[Enter your 64-character hexadecimal key]:"
  # INPUT
    read nm1 #~~Get 64 char hex string as $nm1
  # CALC
    nm2=$(hex2bin $nm1) #~~Convert $nm1 (64 char hex string) to binary as $nm2
    nm3=$(sha_256 $nm2 | awk '{print $1}' | cut -c1-2) #~~Get sha256sum of $nm2 & only record the 1st two chars of the output as $nm3
    nm4=$(hex2bin $nm3) #~~Convert $nm3 (our 2 chars of hex) to binary as $nm4
    nm5=$nm2$nm4 #~~Append our $nm4 (this is the checksum) to $nm2 (orignal string in binary) | this forms a binary that we can use to make our phrase
    for (( i=0; i<${#nm5}; i+=11 )); do nm6=${nm5:$i:11}; echo $((2#${nm6})); done > "$file_numbers" #~~Split $nm5 into 11-bit groups & convert to numbers (which are output to $file_numbers)
    while read line_number; do line_number=$((line_number + 1)); sed -n "${line_number}p" "$bitwords"; done < "$file_numbers" > "$file_phrase" #~~Convert our numbers from $file_numbers to words using $bitwords (wordlist) and output the result to $file_phrase
  # OUTPUT
    clear; echo -e "Private Key (hex):\n $nm1\nEntropy (bin):\n $nm2\nChecksum:\n hex=$nm3\n bin=$nm4\nEntropy w/ Checksum (bin):\n $nm5\n==== Your seed phrase is ===="
    cat "$file_phrase"
    echo -e "\nPLEASE RECORD THIS INFO MANUALLY\n IT WILL DISSAPPEAR WHEN YOU LEAVE\nHit Enter When Ready"; read junk; sleep .5
jumpto mma
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#=== example =================================================================
#  ef235aacf90d9f4aadd8c92e4b2562e1d9eb97f0df9ba3b508258739cb013db2
#  1110111100100011010110101010110011111001000011011001111101001010101011011101100011001001001011100100101100100101011000101110000111011001111010111001011111110000110111111001101110100011101101010000100000100101100001110011100111001011000000010011110110110010
#  01100000
#  111011110010001101011010101011001111100100001101100111110100101010101101110110001100100100101110010010110010010101100010111000011101100111101011100101111111000011011111100110111010001110110101000010000010010110000111001110011100101100000001001111011011001001100000
#  upset bracket private velvet supreme pipe resist bomb comic float flavor senior pact slogan sell vibrant photo portion annual attack original letter walnut equal
#=============================================================================

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma5:
  # INFO
    clear; echo -e "===================== Welcome To Mnemonic 2 Private Key ================================\n  FYI: (it is required to have the word list saved @ ~/a-me/z-share/code/bitwords.txt\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n[Enter your 24 Word Phrase]:"
  # INPUT
    read jj1
  # CALC
    jj2=""
    for word in $jj1; do
      line_number=$(grep -n -w "$word" "$bitwords" | cut -d: -f1)
      line_number=$((line_number - 1))
      jj2+=$(printf "%011d" $(echo "obase=2;$line_number" | bc))
    done
    jj3=${jj2:0:-8} #~~trim the last 8 chars (this removes the checksum)
    jj4=$(bin2hex "$jj3") #jj4=""; for ((i = 0; i < ${#jj3}; i += 4)); do chunk="${jj3:i:4}"; hex_chunk=$(bin_to_hex "$chunk"); jj4="${jj4}${hex_chunk}"; done
  # OUTPUT
    clear
    echo -e "Seed Phrase:\n $jj1\nEntropy w/ Checksum (bin):\n $jj2\nEntropy no Checksum (bin):\n $jj3\nPrivate Key (hex):\n $jj4"
    echo -e "\nPLEASE RECORD THIS INFO MANUALLY\n IT WILL DISSAPPEAR WHEN YOU LEAVE\nHit Enter When Ready"; read junk; sleep .5
jumpto mma
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma6:
  clear
  echo '== BASE Converter ==='
  echo '(1) HEX 2 BIN'
  echo '(2) HEX 2 DEC'
  echo '(3) BIN 2 HEX'
  echo '(4) BIN 2 DEC'
  echo '(5) DEC 2 HEX'
  echo '(6) DEC 2 BIN'
  echo '(7) WIF 2 PRV (BASE58 WIF TO HEX PRIVATE KEY)'
  echo '(8) hex 2 b6 (hex TO base6)'
  echo '(9) b6 2 hex (base6 to base16) [good for dice]'
  echo '(0) roll dice as base6'
  echo '(\) EXIT'; read -rsn1 inkey; echo; inkey=${inkey,,}; clear; case "$inkey" in
  ### CASES #########
  '1') jumpto mma6a ;;
  '2') jumpto mma6b ;;
  '3') jumpto mma6c ;;
  '4') jumpto mma6d ;;
  '5') jumpto mma6e ;;
  '6') jumpto mma6f ;;
  '7') jumpto mma6g ;;
  '8') jumpto mma6h ;;
  '9') jumpto mma6i ;;
  '0') jumpto mma6j ;;
  '\') jumpto mma;; *) jumpto mma6 ;; esac
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma6a:
  # INFO
    echo 'hex2bin: Enter Your Number'
  # INPUT
    read hex2bin_IN; echo '.............................'
  # CALC
    hex2bin_OUT=$(hex2bin "$hex2bin_IN")
  # OUTPUT
    toclip "$hex2bin_OUT"
    echo -e "hex2bin  (Length= ${#hex2bin_OUT})\n  $hex2bin_OUT\n\n* Results Available On ClipBoard *"
    sleep .5; crap
jumpto mma6
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma6b:
  # INFO
    echo 'hex2dec: Enter Your Number'
  # INPUT
    read hex2dec_IN
  # CALC
    hex2dec_OUT=$(hex2dec "$hex2dec_IN")
  # OUTPUT
    toclip "$hex2dec_OUT"
    echo -e "hex2dec  (Length= ${#hex2dec_OUT})\n  $hex2dec_OUT\n\n* Results Available On Clipboard *"
    sleep .5; crap
jumpto mma6  # Return to the main menu
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma6c:
  # INFO
    echo 'bin2hex: Enter Your Number'
  # INPUT
    read bin2hex_IN
  # CALC
    bin2hex_OUT=$(bin2hex "$bin2hex_IN")
  # OUTPUT
    toclip "$bin2hex_OUT"
    echo -e "bin2hex  (Length= ${#bin2hex_OUT})\n  $bin2hex_OUT\n\n* Results Available On Clipboard *"
    sleep .5; crap
jumpto mma6  # Return to the main menu
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma6d:
  # INFO
    echo 'bin2dec: Enter Your Number'
  # INPUT
    read bin2dec_IN
  # CALC
    bin2dec_OUT=$(bin2dec "$bin2dec_IN")
  # OUTPUT
    toclip "$bin2dec_OUT"
    echo -e "bin2dec  (Length= ${#bin2dec_OUT})\n  $bin2dec_OUT\n\n* Results Available On Clipboard *"
    sleep .5; crap
jumpto mma6  # Return to the main menu
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma6e:
  # INFO
    echo 'dec2hex: Enter Your Number'
  # INPUT
    read dec2hex_IN
  # CALC
    dec2hex_OUT=$(dec2hex "$dec2hex_IN")
  # OUTPUT
    toclip "$dec2hex_OUT"
    echo -e "dec2hex  (Length= ${#dec2hex_OUT})\n  $dec2hex_OUT\n\n* Results Available On Clipboard *"
    sleep .5; crap
jumpto mma6  # Return to the main menu
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma6f:
  # INFO
    echo 'dec2bin: Enter Your Number'
  # INPUT
    read dec2bin_IN
  # CALC
    dec2bin_OUT=$(dec2bin "$dec2bin_IN")
  # OUTPUT
    toclip "$dec2bin_OUT"
    echo -e "dec2bin  (Length= ${#dec2bin_OUT})\n  $dec2bin_OUT\n\n* Results Available On Clipboard *"
    sleep .5; crap
jumpto mma6  # Return to the main menu
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma6g:
  # INFO
    echo 'WIF 2 PRV (BASE58 WIF TO HEX PRIVATE KEY)'
  # INPUT
    read wif2prv_IN
  # CALC
    wif2prv_OUT=$(wif2prv "$wif2prv_IN")
  # OUTPUT
    toclip "$wif2prv_OUT"
    echo -e "WIF 2 PRV  (Length= ${#wif2prv_OUT})\n  $wif2prv_OUT\n\n* Results Available On Clipboard *"
    sleep .5; crap
jumpto mma6  # Return to the main menu
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma6h:
  # INFO
    echo 'hex to b6'
  # INPUT
    read hex2b6_IN
  # CALC
    hex2b6_OUT=$(hex2b6 "$hex2b6_IN")
  # OUTPUT
    toclip "$hex2b6_OUT"
    echo -e "hex to b6 (Length= ${#hex2b6_OUT})\n  $hex2b6_OUT\n\n* Results Available On Clipboard *"
    sleep .5; crap
jumpto mma6  # Return to the main menu
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma6i:

  # INFO
    echo 'b6 to hex (use with dice too [6 on di is 0, 99 rolls]'
  # INPUT
    read b62hex_IN
  # CALC
    b62hex_OUT=$(b62hex "$b62hex_IN")
    toclip "$b62hex_OUT"
  # OUTPUT
    echo -e "b6 to hex (Length= ${#b62hex_OUT})\n  $b62hex_OUT\n\n* Results Available On Clipboard *"
    sleep .5; crap
jumpto mma6  # Return to the main menu
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mma6j:
  # INFO / INPUT / CALC
    clear; dice
  # OUTPUT
    toclip "$dice_OUT"
    echo -e "\n----------------------------------------\nDice As Base 6 (Length= ${#dice_OUT})\n  $dice_OUT\n\n* Results Available On Clipboard *"
    sleep .5; crap
jumpto mma6  # Return to the main menu
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#===========================================================================================================================
#== SECTION ================================================================================================================
#
#== SECTION END ============================================================================================================
#===========================================================================================================================
