#!/usr/bin/env bash
# 20231221_14:07_est--EJR
#BaseX EJR: bitcoin calcs
#``````````````````````````````````````````````````````````
#_functions________________________________________________
pf1() {
local Pycode_IN="$1"; local Pycode_SRC=$(cat <<PYEOF
#!/usr/bin/env python3
import os, pyperclip, hashlib, base58, secrets, qrcode, subprocess, sys
from Crypto.Hash import RIPEMD160

# Secp256k1 Curve Parameters
a, b, p, n = 0, 7, 2**256 - 2**32 - 2**9 - 2**8 - 2**7 - 2**6 - 2**4 - 1, 115792089237316195423570985008687907852837564279074904382605163141518161494337
g = {'x': 55066263022277343669578718895168534326250603453777594175500187360389116729240, 'y': 32670510020758816978083085130507043184471273380659243275938904335757337482424}

#= FUNCTIONS ====================================
def modinv(a, m = p):
  a = a % m if a < 0 else a; prevy, y = 0, 1
  while a > 1:
    q = m // a; y, prevy = prevy - q * y, y; a, m = m % a, a
  return y

def double(point):
  slope = ((3 * point['x'] ** 2) * modinv((2 * point['y']))) % p; x = (slope ** 2 - (2 * point['x'])) % p; y = (slope * (point['x'] - x) - point['y']) % p
  return {'x': x, 'y': y}

def add(point1, point2):
  if point1 == point2:
    return double(point1)
  slope = ((point1['y'] - point2['y']) * modinv(point1['x'] - point2['x'])) % p; x = (slope ** 2 - point1['x'] - point2['x']) % p; y = ((slope * (point1['x'] - x)) - point1['y']) % p
  return {'x': x, 'y': y}

def multiply(k, point = g):
  current = point; binary = format(k, 'b')[1:]
  for char in binary:
    current = double(current)
    if char == '1':
      current = add(current, point)
  return current

def Prv_key_to_wif(Prv_key_hex):
  extended = "80" + Prv_key_hex + "01"; checksum = hashlib.sha256(hashlib.sha256(bytes.fromhex(extended)).digest()).digest()[:4]; extended_checksum = extended + checksum.hex(); wif = base58.b58encode(bytes.fromhex(extended_checksum)).decode()
  return wif

def hash160(data):
  binary = bytes.fromhex(data); sha256 = hashlib.sha256(binary).digest(); ripemd160 = RIPEMD160.new(); ripemd160.update(sha256); hash160_bytes = ripemd160.digest(); hash160_hex = hash160_bytes.hex()
  return hash160_hex

#= User Choice (1=User Input Key / 2=Gen. Key) ==
choice = sys.argv[1]
if choice == '1':
  PvKHex = input()
  if len(PvKHex) != 64:
    print("Invalid Prv key length."); exit()
elif choice == '2':
  prvkeybytes = secrets.token_bytes(32); PvKHex = prvkeybytes.hex()
else:
  print("Invalid choice."); exit()

#= PrvKey to bytes ==========================
prvkeybytes = bytes.fromhex(PvKHex)

#= PrvKey To PubKey ======================
prvkeyint = int.from_bytes(prvkeybytes, byteorder="big"); point = multiply(prvkeyint)

#= Pubic(x,y) to hex ============================
x = format(point['x'], '064x'); y = format(point['y'], '064x')

#= Compressed Pub key ========================
prefix = '02' if point['y'] % 2 == 0 else '03'; PbKHex = prefix + x

#= Hash160 of the Pub key ====================
PbKh160 = hash160(PbKHex); versioned_hash = '00' + PbKh160; checksum = hashlib.sha256(hashlib.sha256(bytes.fromhex(versioned_hash)).digest()).digest()[:4]; final_Addrs = versioned_hash + checksum.hex(); PbAddr = base58.b58encode(bytes.fromhex(final_Addrs)).decode()

#= Prv Key to WIF ===========================
wif = Prv_key_to_wif(PvKHex)

#= VARS =========================================
print(f"{PvKHex}|{wif}|{PbKHex}|{PbKh160}|{PbAddr}", flush=True)
PYEOF
)
local pycode_OUT=$(python3 -c "$Pycode_SRC" "$Pycode_IN")
IFS='|' read -r PvKHex wif PbKHex PbKh160 PbAddr <<< "$pycode_OUT"
}
#+++++++++++++++++++++++
jumpto() { local LV1=$1; local LV2=$(sed -n "/$LV1:/{:a;n;p;ba};" $0 | grep -v ':$'); sleep .1; eval "$LV2"; exit; }
crap() { read -n 1 -p '*ANY-KEY*'; echo; }
GetDeps() { for i in "${Dep_Apt[@]}"; do if ! dpkg -l | grep -q "^ii  $i "; then echo "Installing $i..."; sudo apt install -y "$i"; else echo "You Have $i"; fi; done; for i in "${Dep_Pip3[@]}"; do if ! pip3 show "$i" &> /dev/null; then echo "Installing $i..."; pip3 install "$i"; else echo "$i is already installed."; fi; done; }
toclip() { echo -n "$1" | xclip -selection clipboard; }
makeclipQR() { local In1=$(xclip -o -selection clipboard); if [ -z "$In1" ]; then echo "Clipboard is empty."; return 1; fi; echo "$In1"; qrencode -t ANSIUTF8 "$In1"; }
readclipQR() { xclip -selection clipboard -t image/png -o > /tmp/clipboard.png; local Out=$(zbarimg --quiet --raw /tmp/clipboard.png); echo "Decoded text from QR code:"; echo "$Out"; rm /tmp/clipboard.png; }
#+++++++++++++++++++++++
EncrySSL() { local In="$1"; local Out=$(echo "$In" | openssl aes-256-cbc -a -salt -pass pass:"$EnDePass" -pbkdf2); echo -n "$Out"; }
DecrySSL() { local In="$1"; local Out=$(echo "$In" | openssl aes-256-cbc -d -a -pass pass:"$EnDePass" -pbkdf2); echo -n "$Out"; }
Encry64() { local In="$1"; local Out=$(echo "$In" | base64); echo -n "$Out"; }
Decry64() { local In="$1"; local Out=$(echo "$In" | base64 -d); echo -n "$Out"; }
#+++++++++++++++++++++++
b62hex() { local base6="$1"; local result=$(echo "obase=16; ibase=6; $base6" | bc | tr -d '\n\\'); result=${result,,}; echo "$result"; }
bin2dec() { local bin="$1"; local dec=""; dec=$(echo "ibase=2; $bin" | bc | tr -d '\n\\'); echo "$dec"; }
bin2hex() { local bin="$1"; local hex=""; while (( (i + ${#bin}) % 4 != 0 )); do bin="0$bin"; done; for ((i = 0; i < ${#bin}; i += 4)); do chunk="${bin:i:4}"; case "$chunk" in 0000) hex+="0" ;; 0001) hex+="1" ;; 0010) hex+="2" ;; 0011) hex+="3" ;; 0100) hex+="4" ;; 0101) hex+="5" ;; 0110) hex+="6" ;; 0111) hex+="7" ;; 1000) hex+="8" ;; 1001) hex+="9" ;; 1010) hex+="a" ;; 1011) hex+="b" ;; 1100) hex+="c" ;; 1101) hex+="d" ;; 1110) hex+="e" ;; 1111) hex+="f" ;; *) echo "Invalid binary input: $chunk"; return 1 ;; esac; done; echo "$hex"; }
dec2bin() { local dec="$1"; local hex=$(dec2hex "$dec"); local bin=$(hex2bin "$hex"); echo "$bin"; }
dec2hex() { local dec="$1"; local hex=""; hex=$(echo "ibase=10; obase=16; $dec" | bc); echo "${hex,,}"; }
dice() { local result=""; local roll=""; for ((i = 1; i <= 99; i++)); do clear; echo -e "Roll #$i (Last Roll Was=$roll)\nCurrent Results=$result\nRoll The Dice and Enter The Value\n[1-5 are normal 6=0]"; read -rsn1 roll; result="${result}${roll}"; done; echo "$result"; dice_OUT="$result"; }
hex2b6() { local IN=$(echo "$1" | rev); local dec=$(hex2dec "$IN"); local base6_number=$(echo "obase=6; $dec" | bc | tr -d '\n\\'); echo "$base6_number"; }
hex2bin() { local hex=$1; for ((i=0; i<${#hex}; i++)); do case ${hex:$i:1} in 0) echo -n "0000" ;; 1) echo -n "0001" ;; 2) echo -n "0010" ;; 3) echo -n "0011" ;; 4) echo -n "0100" ;; 5) echo -n "0101" ;; 6) echo -n "0110" ;; 7) echo -n "0111" ;; 8) echo -n "1000" ;; 9) echo -n "1001" ;; [Aa]) echo -n "1010" ;; [Bb]) echo -n "1011" ;; [Cc]) echo -n "1100" ;; [Dd]) echo -n "1101" ;; [Ee]) echo -n "1110" ;; [Ff]) echo -n "1111" ;; esac; done; }
hex2dec() { local hex="$1"; local bin=$(hex2bin "$hex"); local dec=$(bin2dec "$bin"); echo "$dec"; }
Sha256() { echo -n $1 | shasum -a 256 -0 | tr -d '\n\\'; }
wif2prv() { local IN="$1"; local OUT; OUT=$(echo -n "$IN" | base58 -d | xxd -p | tr -d '\n\\'); OUT=${OUT,,}; OUT=${OUT:2}; OUT=${OUT:0:64}; echo "$OUT"; }
#+++++++++++++++++++++++
ToLog() { clear; echo; touch "$PhFN"; > "$PhFN"; touch "$PhF"; > "$PhF"; local PhLN; local PbAddrUrl="https://mempool.space/address/$PbAddr"
  local Tl1="$PvKHex"; local Tl2=$(hex2bin $Tl1); local Tl3=$(Sha256 $Tl2 | awk '{print $1}' | cut -c1-2); local Tl4=$(hex2bin $Tl3); local Tl5=$Tl2$Tl4
  for (( i=0; i<${#Tl5}; i+=11 )); do Tl6=${Tl5:$i:11}; echo $((2#${Tl6})); done > "$PhFN"
  while read PhLN; do PhLN=$((PhLN + 1)); sed -n "${PhLN}p" "$bitwords"; done < "$PhFN" > "$PhF"
  local PhStr=$(cat "$PhF" | tr '\n' ' ' | sed 's/ *$//')
  echo 'saving.......'; touch $logF
  echo -e "=== $(date -u '+%Y-%m-%d %H:%M:%S') UTC === $(date '+%Y-%m-%d %H:%M:%S') LocalTime ===\n" >>$logF
  local TlData=("Private Key: $PvKHex" "WIF: $wif" "Public Key: $PbKHex" "Public Key Hash160: $PbKh160" "Address: $PbAddr" "URL (Bal): $PbAddrUrl")
  for i in "${TlData[@]}"; do qrencode -t ASCIIi "$i" >>$logF; echo -e "\n⬆️ ${i%%:*}⬆️\n" >>$logF; done
  echo -e "Prv Key:\n $PvKHex\n\nWIF:\n $wif\n\nPub Key:\n $PbKHex\n\nPub Key Hash160:\n $PbKh160\n\nPub Addrs:\n $PbAddr\n\nURL (Bal):\n $PbAddrUrl\n-----------------------------------------\nEntropy (bin):\n $Tl2\nChecksum:\n hex=$Tl3\n bin=$Tl4\nEntropy w/ Checksum (bin):\n $Tl5\n\n==== Your seed phrase is ====\n$PhStr\n............................................" >>$logF
  echo "**** Saved In File: $logF ****"; }
#+++++++++++++++++++++++
ToTerm() { clear; echo; touch "$PhFN"; > "$PhFN"; touch "$PhF"; > "$PhF"; local PhLN; local PbAddrUrl="https://mempool.space/address/$PbAddr"; toclip "$PbAddrUrl"
  local Tt1="$PvKHex"; local Tt2=$(hex2bin $Tt1); local Tt3=$(Sha256 $Tt2 | awk '{print $1}' | cut -c1-2); local Tt4=$(hex2bin $Tt3); local Tt5=$Tt2$Tt4
  for (( i=0; i<${#Tt5}; i+=11 )); do Tt6=${Tt5:$i:11}; echo $((2#${Tt6})); done > "$PhFN"
  while read PhLN; do PhLN=$((PhLN + 1)); sed -n "${PhLN}p" "$bitwords"; done < "$PhFN" > "$PhF"
  local PhStr=$(cat "$PhF" | tr '\n' ' ' | sed 's/ *$//')
  echo '=============== QR CODES =================='
  local TtData=("Private Key: $PvKHex" "WIF: $wif" "Public Key: $PbKHex" "Public Key Hash160: $PbKh160" "Address: $PbAddr" "URL (Bal): $PbAddrUrl")
  for i in "${TtData[@]}"; do qrencode -t ASCIIi "$i"; echo -e "\n⬆️ ${i%%:*}⬆️\n"; done
  echo -e "Prv Key:\n $PvKHex\n\nWIF:\n $wif\n\nPub Key:\n $PbKHex\n\nPub Key Hash160:\n $PbKh160\n\nAddrs:\n $PbAddr\n\nURL (Bal) [On Clipboard]:\n $PbAddrUrl\n-----------------------------------------\nEntropy (bin):\n $Tt2\nChecksum:\n hex=$Tt3\n bin=$Tt4\nEntropy w/ Checksum (bin):\n $Tt5\n\n==== Your seed phrase is ====\n$PhStr\n............................................"; }
#``````````````````````````````````````````````````````````
#__vars____________________________________________________
logF="$HOME/Desktop/basex.txt"
Dep_Apt=(python3-pip qrencode xclip) # FUTURE?: (base58 basez gnupg imagemagick oathtool openssl ruby-ascii85 tesseract-ocr zbar-tools)
Dep_Pip3=(mnemonic ecdsa pycryptodome pyperclip qrcode base58)
PhFN="/tmp/numbers.txt"
PhF="/tmp/seed_phrase.txt"
bitwords="$HOME/a-me/z-share/code/bitwords.txt"

EnDeClip=""
EnDePass=""
EnInSSL=""
EnMessSSL=""
DeInSSL=""
DeMessSSL=""

EnIn64=""
EnMess64=""
DeIn64=""
DeMess64=""
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma:
clear
echo '(1) Enter Prv Key'
echo '(2) Generate New Prv Key'
echo '(3) Dependency Installer'
echo '(4) Mnemonic Generator via Prv key ..REQUIRES A Prv KEY..'
echo '(5) Mnemonic 2 Prv Key             ..REQUIRES MNEMONIC..'
echo '(0) Base Converter Calculators'
echo '(-) En/Decrypt Messages'
echo '(\) EXIT'; read -rsn1 InKey; echo; InKey=${InKey,,}; clear; case "$InKey" in
### CASES #########
'1') echo 'Enter Prv Key:'; pf1 '1';;
'2') pf1 '2';;
'3') GetDeps; crap; jumpto mma;;
'4') jumpto mma4;;
'5') jumpto mma5;;
'0') jumpto mma0;;
'-') jumpto mmam;;
'\') exit 0;; *) jumpto mma;; esac; jumpto mmb
#``````````````````````````````````````````````````````````
#__________________________________________________________
mmb:
clear
echo '(1) See Output'
echo "(2) See Output AND Save To $logF"
echo "(3) Just Save To $logF"
echo "(4) Delete $logF"
echo '(\) Back To Main Menu'; read -rsn1 InKey; echo; InKey=${InKey,,}; clear; case "$InKey" in
### CASES #########
'1') ToTerm;;
'2') ToLog; ToTerm;;
'3') ToLog;;
'4') rm "$logF";;
'\') jumpto mma;; *) jumpto mmb;; esac; crap; jumpto mmb
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma4:
clear; echo -e "==== PrvKey 2 Mnemonic ====\n  FYI: (Requires File @ ~/a-me/z-share/code/bitwords.txt\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nEnter Hex Key:"
read Pv2Mn1; Pv2Mn2=$(hex2bin $Pv2Mn1); if [ ${#Pv2Mn1} -eq 64 ]; then Pv2Mn3=$(Sha256 $Pv2Mn2 | awk '{print $1}' | cut -c1-2)
elif [ ${#Pv2Mn1} -eq 32 ]; then Pv2Mn3=$(Sha256 $Pv2Mn2 | awk '{print substr($1,1,1)}'); else clear; echo 'Issue In Hex Length'; sleep 2; jumpto mma; fi
Pv2Mn4=$(hex2bin $Pv2Mn3); Pv2Mn5=$Pv2Mn2$Pv2Mn4; for (( i=0; i<${#Pv2Mn5}; i+=11 )); do Pv2Mn6=${Pv2Mn5:$i:11}; echo $((2#${Pv2Mn6})); done > "$PhFN"
while read PhLN; do PhLN=$((PhLN + 1)); sed -n "${PhLN}p" "$bitwords"; done < "$PhFN" > "$PhF"; PhStr=$(cat "$PhF" | tr '\n' ' ' | sed 's/ *$//'); toclip "$PhStr"
clear; echo -e "Prv Key (hex):\n $Pv2Mn1\nEntropy (bin):\n $Pv2Mn2\nChecksum:\n hex=$Pv2Mn3\n bin=$Pv2Mn4\nEntropy w/ Checksum (bin):\n $Pv2Mn5\n==== Your seed phrase (On ClipBoard Too)====\n $PhStr"
echo -e "\nPLEASE RECORD THIS INFO MANUALLY\n IT WILL DISSAPPEAR WHEN YOU LEAVE\nHit Enter When Ready"; read junk; sleep .5
jumpto mma
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma5:
clear; echo -e "==== Mnemonic 2 PrvKey ====\n  FYI: (Requires File @ ~/a-me/z-share/code/bitwords.txt\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nEnter Phrase:"
read Mn2Pv1; Mn2Pv2=""
for word in $Mn2Pv1; do PhLN=$(grep -n -w "$word" "$bitwords" | cut -d: -f1); PhLN=$((PhLN - 1)); Mn2Pv2+=$(printf "%011d" $(echo "obase=2;$PhLN" | bc)); done
if [ ${#Mn2Pv2} -eq 264 ]; then Mn2Pv3="${Mn2Pv2:0:-8}"; elif [ ${#Mn2Pv2} -eq 132 ]; then Mn2Pv3="${Mn2Pv2:0:-4}"; else clear; echo 'Length issue with words'; sleep 2; jumpto mma; fi
Mn2Pv4=$(bin2hex "$Mn2Pv3"); toclip "$Mn2Pv4"; clear
echo -e "Seed Phrase:\n $Mn2Pv1\nEntropy w/ Checksum (bin):\n $Mn2Pv2\nEntropy no Checksum (bin):\n $Mn2Pv3\nPrv Key in hex (length= ${#Mn2Pv4}):\n $Mn2Pv4  <== [On Clipboard]"
echo -e "\nPLEASE RECORD THIS INFO MANUALLY\n IT WILL DISSAPPEAR WHEN YOU LEAVE\nHit Enter When Ready"; read junk; sleep .5
jumpto mma
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma0:
clear
echo '== BASE Converter ==='
echo '(1) HEX 2 BIN'
echo '(2) HEX 2 DEC'
echo '(3) BIN 2 HEX'
echo '(4) BIN 2 DEC'
echo '(5) DEC 2 HEX'
echo '(6) DEC 2 BIN'
echo '(7) WIF 2 PRV (BASE58 WIF TO HEX Prv KEY)'
echo '(8) hex 2 b6 (hex TO base6)'
echo '(9) b6 2 hex (base6 to base16) [good for dice]'
echo '(0) roll dice as base6'
echo '(-) Binary 2 Sha_256'
echo '(\) EXIT'; read -rsn1 InKey; echo; InKey=${InKey,,}; clear; case "$InKey" in
### CASES #########
'1') jumpto mma0a ;;
'2') jumpto mma0b ;;
'3') jumpto mma0c ;;
'4') jumpto mma0d ;;
'5') jumpto mma0e ;;
'6') jumpto mma0f ;;
'7') jumpto mma0g ;;
'8') jumpto mma0h ;;
'9') jumpto mma0i ;;
'0') jumpto mma0j ;;
'-') jumpto mma0m ;;
'\') jumpto mma;; *) jumpto mma0 ;; esac
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma0a:
echo 'hex2bin: Enter Your Number'; read hex2bin_IN; echo '.............................'; hex2bin_OUT=$(hex2bin "$hex2bin_IN"); toclip "$hex2bin_OUT"; echo -e "hex2bin  (Length= ${#hex2bin_OUT})\n  $hex2bin_OUT\n\n* Results Available On ClipBoard *"; sleep .5; crap
jumpto mma0
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma0b:
echo 'hex2dec: Enter Your Number'; read hex2dec_IN; hex2dec_OUT=$(hex2dec "$hex2dec_IN"); toclip "$hex2dec_OUT"; echo -e "hex2dec  (Length= ${#hex2dec_OUT})\n  $hex2dec_OUT\n\n* Results Available On Clipboard *"; sleep .5; crap
jumpto mma0
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma0c:
echo 'bin2hex: Enter Your Number'; read bin2hex_IN; bin2hex_OUT=$(bin2hex "$bin2hex_IN"); toclip "$bin2hex_OUT"; echo -e "bin2hex  (Length= ${#bin2hex_OUT})\n  $bin2hex_OUT\n\n* Results Available On Clipboard *"; sleep .5; crap
jumpto mma0
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma0d:
echo 'bin2dec: Enter Your Number'; read bin2dec_IN; bin2dec_OUT=$(bin2dec "$bin2dec_IN"); toclip "$bin2dec_OUT"; echo -e "bin2dec  (Length= ${#bin2dec_OUT})\n  $bin2dec_OUT\n\n* Results Available On Clipboard *"; sleep .5; crap
jumpto mma0
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma0e:
echo 'dec2hex: Enter Your Number'; read dec2hex_IN; dec2hex_OUT=$(dec2hex "$dec2hex_IN"); toclip "$dec2hex_OUT"; echo -e "dec2hex  (Length= ${#dec2hex_OUT})\n  $dec2hex_OUT\n\n* Results Available On Clipboard *"; sleep .5; crap
jumpto mma0
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma0f:
echo 'dec2bin: Enter Your Number'; read dec2bin_IN; dec2bin_OUT=$(dec2bin "$dec2bin_IN"); toclip "$dec2bin_OUT"; echo -e "dec2bin  (Length= ${#dec2bin_OUT})\n  $dec2bin_OUT\n\n* Results Available On Clipboard *"; sleep .5; crap
jumpto mma0
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma0g:
echo 'WIF 2 PRV (BASE58 WIF TO HEX Prv KEY)'; read wif2prv_IN; wif2prv_OUT=$(wif2prv "$wif2prv_IN"); toclip "$wif2prv_OUT"; echo -e "WIF 2 PRV  (Length= ${#wif2prv_OUT})\n  $wif2prv_OUT\n\n* Results Available On Clipboard *"; sleep .5; crap
jumpto mma0
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma0h:
echo 'hex to b6'; read hex2b6_IN; hex2b6_OUT=$(hex2b6 "$hex2b6_IN"); toclip "$hex2b6_OUT"; echo -e "hex to b6 (Length= ${#hex2b6_OUT})\n  $hex2b6_OUT\n\n* Results Available On Clipboard *"; sleep .5; crap
jumpto mma0
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma0i:
echo 'b6 to hex (use with dice too [6 on di is 0, 99 rolls]'; read b62hex_IN; b62hex_OUT=$(b62hex "$b62hex_IN"); toclip "$b62hex_OUT"; echo -e "b6 to hex (Length= ${#b62hex_OUT})\n  $b62hex_OUT\n\n* Results Available On Clipboard *"; sleep .5; crap
jumpto mma0
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma0j:
clear; dice; toclip "$dice_OUT"; echo -e "\n----------------------------------------\nDice As Base 6 (Length= ${#dice_OUT})\n  $dice_OUT\n\n* Results Available On Clipboard *"; sleep .5; crap
jumpto mma0
#``````````````````````````````````````````````````````````
#__________________________________________________________
mma0m:
echo 'Enter binary to be checksummed:'; read bin2sha256_IN; bin2sha256_OUT=$(Sha256 "$bin2sha256_IN"); toclip "$bin2sha256_OUT"; echo -e "Your Checmsum (Length= ${#bin2sha256_OUT})\n  $bin2sha256_OUT\n\n* Results Available On Clipboard *"; sleep .5; crap
jumpto mma0
#``````````````````````````````````````````````````````````

#__________________________________________________________
mmam:
clear
echo "Current Password: $EnDePass"
echo '== Message En/DeCrypter'
echo ' 1 - Enter Password (run 1st)'
echo ' 2 - Encrypt (OpenSSL)'
echo ' 3 - Decrypt (OpenSSL)'
echo ' 4 - Encrypt (base64)'
echo ' 5 - Decrypt (base64)'
echo ' 9 - Make Clip QR'
echo ' 0 - Read Clip QR'
echo ' - - Status'
echo ' \ - Exit'
read -rsn1 InKey; echo; InKey=${InKey,,}; clear; case "$InKey" in
### CASES #########
'1') jumpto mmam1 ;;
'2') jumpto mmam2 ;;
'3') jumpto mmam3 ;;
'4') jumpto mmam4 ;;
'5') jumpto mmam5 ;;
'9') jumpto mmam9 ;;
'0') jumpto mmam0 ;;
'-') jumpto mmamm ;;
'\') jumpto mma;; *) jumpto mmam ;; esac
#``````````````````````````````````````````````````````````
#__________________________________________________________
mmam1:
EnDePass=""
echo "Enter password:"
read -r EnDePass; EnDePass=$(echo -n "$EnDePass")
jumpto mmam
#``````````````````````````````````````````````````````````
#__________________________________________________________
mmam2:
EnInSSL=""
EnMessSSL=""
echo "Enter Raw Message (Press Ctrl+D On New Line When Done):"
while IFS= read -r line; do EnInSSL="${EnInSSL}${line}"$'\n'; done; EnInSSL=$(echo -n "$EnInSSL")
EnMessSSL=$(EncrySSL "$EnInSSL"); toclip "$EnMessSSL"
clear; echo -e "Encrypted Message (also on clipboard now):\n$EnMessSSL"; crap
jumpto mmam
#``````````````````````````````````````````````````````````
#__________________________________________________________
mmam3:
DeInSSL=""
DeMessSSL=""
echo "What's the encrypted message you want to decode?"
read -r DeInSSL; DeInSSL=$(echo -n "$DeInSSL")
DeMessSSL=$(DecrySSL "$DeInSSL"); toclip "$DeMessSSL"
clear; echo -e "Decrypted Message (also on clipboard now):\n$DeMessSSL"; crap
jumpto mmam
#``````````````````````````````````````````````````````````
#__________________________________________________________
mmam4:
EnIn64=""
EnMess64=""
echo "Enter Raw Message (Press Ctrl+D On New Line When Done):"
while IFS= read -r line; do EnIn64="${EnIn64}${line}"$'\n'; done; EnIn64=$(echo -n "$EnIn64")
EnMess64=$(Encry64 "$EnIn64"); toclip "$EnMess64"
clear; echo -e "Encryted Message (also on clipboard now):\n$EnMess64"; crap
jumpto mmam
#``````````````````````````````````````````````````````````
#__________________________________________________________
mmam5:
DeIn64=""
DeMess64=""
echo "What's the encrypted message you want to decode?"
read -r DeIn64; DeIn64=$(echo -n "$DeIn64")
DeMess64=$(Decry64 "$DeIn64"); toclip "$DeMess64"
clear; echo -e "Decrypted Message (also on clipboard now):\n$DeMess64"; crap
jumpto mmam
#``````````````````````````````````````````````````````````
#__________________________________________________________
mmam9:
makeclipQR; crap
jumpto mmam
#``````````````````````````````````````````````````````````
#__________________________________________________________
mmam0:
readclipQR; crap
jumpto mmam
#``````````````````````````````````````````````````````````
#__________________________________________________________
mmamm:
EnDeClip=$(xclip -o -selection clipboard); sleep .1; clear
echo -e "
=========Status Report From En/Decoder  ============
****EnCryptSSL Input****
$EnInSSL
****EnCryptSSL Output****
$EnMessSSL
****DeCryptSSL Input****
$DeInSSL
****DeCryptSSL Output****
$DeMessSSL
---------------------------------------
****EnCrypt64 Input****
$EnIn64
****EnCrypt64 Output****
$EnMess64
****DeCrypt64 Input****
$DeIn64
****DeCrypt64 Output****
$DeMess64
---------------------------------------
****Password****
$EnDePass
---------------------------------------
****ClipBoard****
$EnDeClip
---------------------------------------
"
sleep .1; crap
jumpto mmam
#``````````````````````````````````````````````````````````
#__________________________________________________________
