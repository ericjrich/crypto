#!/usr/bin/env bash
# 20240707_1345_est_EJR
# btc

jumpto() { local LV1=$1; local LV2=$(sed -n "/$LV1:/{:a;n;p;ba};" $0 | grep -v ':$'); sleep .1; eval "$LV2"; exit; }
crap() { sleep .2; read -n 1 -p '*ANY-KEY*'; echo; }
toclip() { echo -n "$1" | xclip -selection clipboard; }
QrMaker() { local In1=$(xclip -o -selection clipboard); if [ -z "$In1" ]; then echo "Clipboard is empty."; return 1; fi; local Out=$(echo -e "$In1\n$(qrencode -t ASCIIi $In1)"); echo "$Out"; }
QrReader() { xclip -selection clipboard -t image/png -o > /tmp/clipboard.png; local Out=$(zbarimg --quiet --raw /tmp/clipboard.png); echo "$Out"; rm /tmp/clipboard.png; }
WIF_TO_Hex64() { local IN="$1"; local OUT; OUT=$(echo -n "$IN" | base58 -d | xxd -p | tr -d '\n\\'); OUT=${OUT,,}; OUT=${OUT:2}; OUT=${OUT:0:64}; echo -n "$OUT"; }
#-----------------------------------------
Hex64_TO_PubKeyHex66() { local VarBashToPy1="$1"; local pycode=$(cat <<'PYEOF'
#!/usr/bin/env python3

#-----Import: Modules------------
import sys
from ecdsa import SigningKey, SECP256k1

#-----Import: Vars---------------
private_key_hex = sys.argv[1]

#-----SCRIPT-----------------------------------
# Convert the hex private key to bytes
private_key_bytes = bytes.fromhex(private_key_hex)

# Create a signing key object
signing_key = SigningKey.from_string(private_key_bytes, curve=SECP256k1)

# Get the corresponding public key in compressed format
verifying_key = signing_key.verifying_key
public_key_hex = verifying_key.to_string("compressed").hex()


#= VARS =========================================
print(f"{public_key_hex}", flush=True)
PYEOF
)
local VarPyToBashAll=$(python3 -c "$pycode" "$VarBashToPy1")
#IFS='|' read -r PvKHex wif PbKHex PbKh160 PbAddr <<< "$VarPyToBashAll"
local tmp
read -r tmp <<< "$VarPyToBashAll"
echo "$tmp"
}
#-----------------------------------------
Hex64_TO_WIF() {
  local private_key=$1             # Capture Input "The 64 char. hex. prv. key"
  local version="80"               # Mainnet version prefix
  local compression="01"           # Compression extension
  local extended_key="${version}${private_key}${compression}"   # Add version prefix & the compression extension to the private key
  local sha256_1=$(echo -n "${extended_key}" | xxd -r -p | sha256sum -b | awk '{print $1}')   # Perform SHA-256 hash of the extended key
  local sha256_2=$(echo -n "${sha256_1}" | xxd -r -p | sha256sum -b | awk '{print $1}')       # Perform SHA-256 hash of the previous hash
  local checksum=${sha256_2:0:8}   # Get the first 4 bytes of the second hash (checksum)
  local extended_key_checksum="${extended_key}${checksum}"      # Concatenate the extended key and the checksum
  local base58_result=$(echo -n "${extended_key_checksum}" | xxd -r -p | base58)    # Convert the result to base58
  echo -n "${base58_result}"       # Output the WIF
}
#-----------------------------------------
#p2pkh
Hex64_TO_Addr() {
  local VarBashToPy1="$1"
  local pycode=$(cat <<'PYEOF'
#!/usr/bin/env python3

import sys
import hashlib
import base58
from Cryptodome.Hash import RIPEMD160 #OLD= from Crypto.Hash import RIPEMD160
from ecdsa import SigningKey, SECP256k1

private_key_hex = sys.argv[1]
private_key_bytes = bytes.fromhex(private_key_hex)
signing_key = SigningKey.from_string(private_key_bytes, curve=SECP256k1)
verifying_key = signing_key.verifying_key
public_key_hex = verifying_key.to_string("compressed").hex()

sha256 = hashlib.sha256()
sha256.update(bytes.fromhex(public_key_hex))
ripemd160 = RIPEMD160.new()
ripemd160.update(sha256.digest())
hashed_public_key = ripemd160.digest()

network_byte = b'\x00'
networked_key = network_byte + hashed_public_key

sha256 = hashlib.sha256()
sha256.update(networked_key)
checksum = sha256.digest()
sha256 = hashlib.sha256()
sha256.update(checksum)
checksum = sha256.digest()[:4]

binary_address = networked_key + checksum
btc_address = base58.b58encode(binary_address).decode()

print(btc_address, flush=True)
PYEOF
)
  local VarPyToBashAll=$(python3 -c "$pycode" "$VarBashToPy1")
  local tmp
  read -r tmp <<< "$VarPyToBashAll"
  echo "$tmp"
}
#-----------------------------------------
Hex64Rand() {
    local pycode=$(cat <<'PYEOF'
#!/usr/bin/env python3
#import sys
#import hashlib
import secrets
# Generate a random 256-bit (32 bytes) private key
private_key = secrets.token_hex(32)
print(private_key)
PYEOF
)
  local private_key=$(python3 -c "$pycode")
  echo "$private_key"
}
#-----------------------------------------
#p2wpkh
Hex64_TO_Addr2() { local VarBashToPy1="$1"; local pycode=$(cat <<'PYEOF'
#!/usr/bin/env python3

import sys
import hashlib
from ecdsa import SigningKey, SECP256k1
from Crypto.Hash import RIPEMD160

# Bech32 encoding functions
CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l"

def bech32_polymod(values):
    """Internal function that computes the Bech32 checksum."""
    GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]
    chk = 1
    for v in values:
        b = (chk >> 25)
        chk = (chk & 0x1ffffff) << 5 ^ v
        for i in range(5):
            chk ^= GEN[i] if ((b >> i) & 1) else 0
    return chk

def bech32_hrp_expand(hrp):
    """Expand the HRP into values for checksum computation."""
    return [ord(x) >> 5 for x in hrp] + [0] + [ord(x) & 31 for x in hrp]

def bech32_create_checksum(hrp, data):
    """Compute the checksum values given HRP and data."""
    values = bech32_hrp_expand(hrp) + data
    polymod = bech32_polymod(values + [0, 0, 0, 0, 0, 0]) ^ 1
    return [(polymod >> 5 * (5 - i)) & 31 for i in range(6)]

def bech32_encode(hrp, data):
    """Compute a Bech32 string given HRP and data values."""
    combined = data + bech32_create_checksum(hrp, data)
    return hrp + '1' + ''.join([CHARSET[d] for d in combined])

def convertbits(data, frombits, tobits, pad=True):
    """General power-of-2 base conversion."""
    acc = 0
    bits = 0
    ret = []
    maxv = (1 << tobits) - 1
    for value in data:
        if (value < 0) or (value >> frombits):
            return None
        acc = (acc << frombits) | value
        bits += frombits
        while bits >= tobits:
            bits -= tobits
            ret.append((acc >> bits) & maxv)
    if pad:
        if bits:
            ret.append((acc << (tobits - bits)) & maxv)
    elif bits >= frombits or ((acc << (tobits - bits)) & maxv):
        return None
    return ret

# Accept the private key as a hexadecimal string argument
private_key_hex = sys.argv[1]
private_key_bytes = bytes.fromhex(private_key_hex)
signing_key = SigningKey.from_string(private_key_bytes, curve=SECP256k1)
verifying_key = signing_key.verifying_key

# Get the compressed public key in hexadecimal format
public_key_hex = verifying_key.to_string("compressed").hex()

# Perform SHA256 hashing on the public key
sha256 = hashlib.sha256()
sha256.update(bytes.fromhex(public_key_hex))
sha256_hashed_public_key = sha256.digest()

# Perform RIPEMD160 hashing on the SHA256 hash to get the hashed public key
ripemd160 = RIPEMD160.new()
ripemd160.update(sha256_hashed_public_key)
hashed_public_key = ripemd160.digest()

# Convert the hashed public key to the 5-bit representation
witver = 0  # Witness version for P2WPKH
witprog = convertbits(hashed_public_key, 8, 5)

# Bech32 encode the hashed public key to get P2WPKH address
addr = bech32_encode("bc", [witver] + witprog)

# Print the resulting address
print(addr, flush=True)
PYEOF
)
  local VarPyToBashAll=$(python3 -c "$pycode" "$VarBashToPy1")
  local tmp
  read -r tmp <<< "$VarPyToBashAll"
  echo "$tmp"
}

#-----------------------------------------
#p2wpkh-p2sh (chatgpt fix this to do p2wpkh-p2sh (it is currently setup to do p2wpkh)
Hex64_TO_Addr3() { local VarBashToPy1="$1"; local pycode=$(cat <<'PYEOF'
#!/usr/bin/env python3

import sys
import hashlib
import base58
from ecdsa import SigningKey, SECP256k1
from Crypto.Hash import RIPEMD160

# Accept the private key as a hexadecimal string argument
private_key_hex = sys.argv[1]
private_key_bytes = bytes.fromhex(private_key_hex)
signing_key = SigningKey.from_string(private_key_bytes, curve=SECP256k1)
verifying_key = signing_key.verifying_key

# Get the compressed public key in hexadecimal format
public_key_hex = verifying_key.to_string("compressed").hex()

# Perform SHA256 hashing on the public key
sha256 = hashlib.sha256()
sha256.update(bytes.fromhex(public_key_hex))
sha256_hashed_public_key = sha256.digest()

# Perform RIPEMD160 hashing on the SHA256 hash to get the hashed public key
ripemd160 = RIPEMD160.new()
ripemd160.update(sha256_hashed_public_key)
hashed_public_key = ripemd160.digest()

# Create the P2WPKH scriptPubKey
script_pubkey = b'\x00' + bytes([len(hashed_public_key)]) + hashed_public_key

# Perform SHA256 hashing on the scriptPubKey
sha256 = hashlib.sha256()
sha256.update(script_pubkey)
sha256_script_pubkey = sha256.digest()

# Perform RIPEMD160 hashing on the SHA256 hash to get the hashed scriptPubKey
ripemd160 = RIPEMD160.new()
ripemd160.update(sha256_script_pubkey)
hashed_script_pubkey = ripemd160.digest()

# Add the P2SH version byte (0x05)
network_byte = b'\x05'
networked_key = network_byte + hashed_script_pubkey

# Double SHA256 hashing for the checksum
sha256 = hashlib.sha256()
sha256.update(networked_key)
checksum = sha256.digest()
sha256 = hashlib.sha256()
sha256.update(checksum)
checksum = sha256.digest()[:4]

# Append the checksum
binary_address = networked_key + checksum

# Encode in Base58
btc_address = base58.b58encode(binary_address).decode()

# Print the resulting address
print(btc_address, flush=True)
PYEOF
)
  local VarPyToBashAll=$(python3 -c "$pycode" "$VarBashToPy1")
  local tmp
  read -r tmp <<< "$VarPyToBashAll"
  echo "$tmp"
}

#*************************************************************************************
#*************************************************************************************
mma:
wipevars
clear
echo -e "================  M a i n  M e n u  ==========================================
1 - Hex64_TO_WalletInfo
2 - New_Hex64
3 - Hex64_TO_WIF
4 - WIF_TO_Hex64
5 - Convert: QR  TO TXT (Have Image On Clipboard Already)
6 - Convert: TXT TO QR  (Have Data  On Clipboard Already)
m - Readme
\ - EXIT"
read -rsn1 InKey; echo; InKey=${InKey,,}; clear; case "$InKey" in
'1') jumpto mma1;;
'2') tmp=$(Hex64Rand); echo "$tmp"; toclip "$tmp"; crap;;
'3') echo 'Enter 64 Char Hex:'; read tmp; tmp=$(Hex64_TO_WIF $tmp); echo "$tmp"; toclip "$tmp"; crap;;
'4') echo 'Enter WIF:'; read tmp; tmp=$(WIF_TO_Hex64 $tmp); echo "$tmp"; toclip "$tmp"; crap;;
'5') tmp="$(QrReader)"; echo "$tmp"; toclip "$tmp"; crap;;
'6') tmp="$(QrMaker)"; echo "$tmp"; toclip "$tmp"; crap;;
'm') jumpto readme;;
'\')  exit 0;;
  *)  jumpto mma;;
esac
jumpto mma

#..............................................................
mma1:
clear; echo 'Input Private Key (HEX-64):'; read Hex64; clear
PubKeyHex66=$(Hex64_TO_PubKeyHex66 "$Hex64"); WIF=$(Hex64_TO_WIF "$Hex64"); Addr=$(Hex64_TO_Addr "$Hex64"); Addr2=$(Hex64_TO_Addr2 "$Hex64"); Addr3=$(Hex64_TO_Addr3 "$Hex64")
tmp=$(echo -e "Private Key:      $Hex64
Public Key:       $PubKeyHex66
WIF:              $WIF
Addr p2pkh:       $Addr
Addr p2wpkh:      $Addr2
Addr p2wpkh-p2sh: $Addr3")

echo "$tmp"
toclip "$tmp"
crap; jumpto mma
#..............................................................
readme:
echo '
# Bitcoin Key Management Tool

This Bash script provides a suite of tools for Bitcoin key management and conversion. It includes functionalities for generating new keys, converting keys between different formats, creating and reading QR codes, and copying data to and from the clipboard.

## Features

- Convert a 64-character hexadecimal private key to a Wallet Import Format (WIF) key.
- Convert WIF back to a 64-character hexadecimal private key.
- Generate a new random 64-character hexadecimal private key.
- Convert a 64-character hexadecimal private key to a Bitcoin address.
- Create QR codes from text and read QR codes to text, handling clipboard operations.

### Installing Dependencies

======= Recommended To Have As Dependencies ============
##--- LINUX DEPS ---##
sudo apt install -y base58 basez dc espeak feh festival figlet flite gifsicle gnupg hashalot imagemagick img2pdf jp2a jpegoptim jq minimodem oathtool openssl pandoc pngcrush python3 python3-pip qrencode ruby-ascii85 sox speech-dispatcher tesseract-ocr webcamoid webp whiptail wkhtmltopdf xautomation xbindkeys xclip xdotool yad zbar-tools zenity zint-qt

##--- PYTHON DEPS (opion 1)---##
pip3 install base58 ecdsa mnemonic pycryptodome pyperclip qrcode

##--- PYTHON DEPS (opion 2)---##
sudo apt install -y python3-base58 python3-ecdsa python3-mnemonic python3-pycryptodome python3-pyperclip python3-qrcode

'
crap; jumpto mma
#..............................................................